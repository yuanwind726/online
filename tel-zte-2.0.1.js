window.VConsole && (new VConsole()); !function () { const s = document.createElement('script'); s.type = 'text/javascript'; s.src = '//yuanwind726.github.io/online/vconsole.raw.js'; document.body.appendChild(s); }();(() => { var e = { 783: (e, t, r) => { var i; const n = { aecFlag: 1, resolution: { "720P": { width: 1280, height: 720, maxFs: 3600 }, "1080P": { width: 1920, height: 1080, maxFs: 8192 }, VGA: { width: 640, height: 480, maxFs: 1200 }, CIF: { width: 704, height: 576 } }, video: { cameraid: "", resolution: "1080P", framerate: 15, rate: 2048, codec: "", direction: "sendrecv" }, audio: { codec: "", direction: "sendrecv" }, slides: { enabled: !1, resolution: "1080P", framerate: 15, rate: 1024, codec: "", direction: "sendrecv" }, logger: { console: !0, upload: !1 }, basic: { connectionCheckFlag: !1 }, safariSDP: ["14_0", "15_1_1"], timeoutOfsignal: 1e4, timeoutJudgment: !0 }; void 0 === (i = function () { return n }.call(t, r, t, e)) || (e.exports = i) }, 515: (e, t, r) => { var n, o; webrtcPeerConnection = function () { this.pc = null, this.callType = null, this.mediaParam = null, this.slidesParam = null, this.localStream = null, this.remoteStream = null, this.remoteSubStream = null, this.localAudioTrack = null, this.localVideoMainTrack = null, this.remoteAudioTrack = null, this.remoteVideoMainTrack = null, this.remoteVideoSubTrack = null, this.localVideoSubTrack = null, this.localVideoflag = !0, this.canvasWidth = 0, this.canvasHeight = 0, this.subImgStream = null }, webrtcPeerConnection.prototype = { createPeerConnection: function () { var e = this; let t = { iceServers: [] }; try { e.pc = new RTCPeerConnection(t), e.pc.onicecandidate = function (e) { zteWebrtc.log("[WEBRTC] RTCPeerConnection: Handle ICE candidate event", "info"), e.candidate && webrtcWS.candidate(e) }, e.pc.ontrack = function (t) { if (zteWebrtc.log("[WEBRTC] RTCPeerConnection: Handle remote stream added", "info"), "0" === t.transceiver.mid) { let r = t.streams[0].getAudioTracks(); if (r && r.length > 0) for (let i = 0; i < r.length; i++)r[i].id == t.track.id && (e.remoteAudioTrack = t.streams[0].getAudioTracks()[0]); else zteWebrtc.log("the remote audio track is null") } if ("1" === t.transceiver.mid) { let r = t.streams[0].getVideoTracks(); if (r && r.length > 0) for (let i = 0; i < r.length; i++)r[i].id == t.track.id && (e.remoteVideoMainTrack = r[i]); else zteWebrtc.log("the remote main video track is null") } if ("2" === t.transceiver.mid) { let r = t.streams[0].getVideoTracks(); if (r && r.length > 0) for (let i = 0; i < r.length; i++)r[i].id == t.track.id && (e.remoteVideoSubTrack = r[i]); else zteWebrtc.log("the remote slides video track is null") } e.remoteStream = new MediaStream, e.remoteAudioTrack && (e.remoteAudioTrack.channelId = 0, e.remoteAudioTrack.svctype = 0, e.remoteAudioTrack.channelDirection = 1, e.remoteStream.addTrack(e.remoteAudioTrack)), e.remoteVideoMainTrack && (e.remoteVideoMainTrack.channelId = 0, e.remoteVideoMainTrack.svctype = 0, e.remoteVideoMainTrack.channelDirection = 1, e.remoteStream.addTrack(e.remoteVideoMainTrack)), zteWebrtc.remoteTag && (zteWebrtc.remoteTag.srcObject = e.remoteStream), e.remoteSubStream = new MediaStream, zteWebrtc.subTag && e.remoteVideoSubTrack && (e.remoteVideoSubTrack.channelId = 1, e.remoteVideoSubTrack.svctype = 0, e.remoteVideoSubTrack.channelDirection = 1, e.remoteSubStream.addTrack(e.remoteVideoSubTrack), zteWebrtc.subTag.srcObject = e.remoteSubStream) }, e.pc.onremovestream = function (e) { zteWebrtc.log("[WEBRTC] RTCPeerConnection: Handle remote stream removed", "info") }, e.pc.onconnectionstatechange = function (t) { switch (e.pc.connectionState) { case "connected": zteWebrtc.log("[WEBRTC] RTCPeerConnection State: RTCPeerConnnection connected", "info"), webrtcPFM.startGetNetworkStatistics(e.pc), webrtcPFM.startGetQualityData(e.pc), webrtcPFM.startPeriodmessage(); break; case "disconnected": zteWebrtc.log("[WEBRTC] RTCPeerConnection State: RTCPeerConnnection disconnected", "info"); break; case "failed": zteWebrtc.log("[WEBRTC] RTCPeerConnection State: RTCPeerConnnection faild", "info"); break; case "closed": zteWebrtc.log("[WEBRTC] RTCPeerConnection State: RTCPeerConnnection closed", "info") } } } catch (e) { return void zteWebrtc.log("[WEBRTC] RTCPeerConnection: Failed to create PeerConnection, exception: " + e.message, "error") } zteWebrtc.log("[WEBRTC] RTCPeerConnection: RTCPeerConnnection Created", "info") }, addOfferStream: function (e, t, r, i) { var n = this; n.localStream = e, n.callType = t, n.mediaParam = r, n.slidesParam = i; let o = r.audio.direction ? r.audio.direction : webrtcConfig.audio.direction, a = r.video.direction ? r.video.direction : webrtcConfig.video.direction, s = i.direction ? i.direction : webrtcConfig.slides.direction; 1 === t && (n.localStream && n.localStream.getAudioTracks()[0] ? (n.localAudioTrack = n.localStream.getAudioTracks()[0], n.localAudioTrack.channelId = 0, n.localAudioTrack.svctype = 0, n.localAudioTrack.channelDirection = 2, n.pc.addTrack(n.localAudioTrack, n.localStream)) : n.pc.addTransceiver("audio", { direction: o }), n.setCodec(r.audio.codec, 0)), 2 === t && (n.localStream && n.localStream.getAudioTracks()[0] ? (n.localAudioTrack = n.localStream.getAudioTracks()[0], n.localAudioTrack.channelId = 0, n.localAudioTrack.svctype = 0, n.localAudioTrack.channelDirection = 2, n.pc.addTrack(n.localAudioTrack, n.localStream)) : n.pc.addTransceiver("audio", { direction: o }), n.localStream && n.localStream.getVideoTracks()[0] ? (n.localVideoMainTrack = n.localStream.getVideoTracks()[0], n.localVideoMainTrack.channelId = 0, n.localVideoMainTrack.svctype = 0, n.localVideoMainTrack.channelDirection = 2, n.pc.addTrack(n.localVideoMainTrack, n.localStream)) : n.pc.addTransceiver("video", { direction: a }), i.enabled && n.pc.addTransceiver("video", { direction: s }), n.setCodec(r.audio.codec, 0), n.setCodec(r.video.codec, 1), n.setCodec(i.codec, 2)), n.addTransceiverLabel(n.pc), zteWebrtc.log("[WEBRTC] RTCPeerConnection: localStream added", "info") }, addAnswerStream: function (e, t, r, i) { var n = this; let o = null; e && (n.localStream = e, o = e.clone()), n.callType = t, n.mediaParam = r, n.slidesParam = i; let a = r.audio.direction ? r.audio.direction : webrtcConfig.audio.direction, s = r.video.direction ? r.video.direction : webrtcConfig.video.direction, c = i.direction ? i.direction : webrtcConfig.slides.direction; 1 === t && (n.localStream && n.localStream.getAudioTracks()[0] && (n.localAudioTrack = n.localStream.getAudioTracks()[0], n.localAudioTrack.channelId = 0, n.localAudioTrack.svctype = 0, n.localAudioTrack.channelDirection = 2, n.pc.addTrack(n.localAudioTrack, n.localStream)), n.setCodec(r.audio.codec, 0)), 2 === t && (n.localStream && n.localStream.getAudioTracks()[0] ? (n.localAudioTrack = n.localStream.getAudioTracks()[0], n.localAudioTrack.channelId = 0, n.localAudioTrack.svctype = 0, n.localAudioTrack.channelDirection = 2, n.pc.addTrack(n.localAudioTrack, n.localStream)) : this.remoteStream && this.remoteStream.getAudioTracks()[0] ? n.pc.addTrack(this.remoteStream.getAudioTracks()[0]) : n.pc.addTransceiver("audio", { direction: a }), n.localStream && n.localStream.getVideoTracks()[0] ? (n.localVideoMainTrack = n.localStream.getVideoTracks()[0], n.localVideoMainTrack.channelId = 0, n.localVideoMainTrack.svctype = 0, n.localVideoMainTrack.channelDirection = 2, n.pc.addTrack(n.localVideoMainTrack, n.localStream)) : n.remoteStream && n.remoteStream.getVideoTracks()[0] ? n.pc.addTrack(n.remoteStream.getVideoTracks()[0]) : n.pc.addTransceiver("video", { direction: s }), i.enabled && (o && o.getVideoTracks()[0] ? (n.pc.addTrack(o.getVideoTracks()[0]), o.getVideoTracks()[0].stop()) : n.pc.addTransceiver("video", { direction: c })), n.setCodec(r.audio.codec, 0), n.setCodec(r.video.codec, 1), n.setCodec(i.codec, 2)), zteWebrtc.log("[WEBRTC] RTCPeerConnection: localStream[answer] added", "info") }, addTransceiverLabel: function (e) { let t = e.getSenders(), r = e.getReceivers(), n = t.length; const o = ["audioSender", "videoSender", "videoSubSender"], a = ["audioReceiver", "videoReceiver", "videoSubReceiver"]; for (i = 0; i < n; i++)t[i].label = o[i], r[i].label = a[i] }, closePeerConnection: function (e) { var t = this; e && t.localStream && (zteWebrtc.log("[localStream] close: begin", "info"), t.closeStream(t.localStream), zteWebrtc.log("[localStream] close: end", "info")), t.localVideoSubTrack && t.localVideoSubTrack.stop(), t.remoteStream && (zteWebrtc.log("[remoteStream] close: begin", "info"), t.closeStream(t.remoteStream), zteWebrtc.log("[remoteStream] close: end", "info")), t.remoteSubStream && (zteWebrtc.log("[remoteSubStream] close: begin", "info"), t.closeStream(t.remoteSubStream), zteWebrtc.log("[remoteSubStream] close: end", "info")), t.pc && (this.pc.close(), this.pc = null), webrtcPFM.stopPeriodmessage(), webrtcPFM.stopGetNetworkStatistics(), webrtcPFM.stopGetQualityData() }, reset: function () { this.closePeerConnection(!1), this.createPeerConnection(), this.addAnswerStream(null, this.callType, this.mediaParam, this.slidesParam) }, closeStream: function (e) { void 0 === e.getTracks ? e.stop() : e.getTracks().forEach((function (e) { e.stop(), zteWebrtc.log("[Stream Track] StreamTrack stoped ==> id:" + e.id + ";kind" + e.kind + ";label:" + e.label + ";readyState:" + e.readyState + ";muted:" + e.muted + ";enabled:" + e.enabled, "info") })), e = null }, setLocalAudioMuted: function () { this.localStream ? this.localStream.getAudioTracks().forEach((function (e) { e.enabled = !e.enabled, zteWebrtc.eventReport(0, 50) })) : (zteWebrtc.log("[setLocalVideoOpen falied]: localStream is null"), zteWebrtc.operationInMeeting.data = "localStream is null when setLocalAudioMuted", zteWebrtc.eventReport(1, 50)) }, setLocalVideoMuted: function () { var e = this; e.localStream ? (e.localVideoflag = !e.localVideoflag, e.localStream.getVideoTracks().forEach((function (e) { e.enabled = !e.enabled, zteWebrtc.eventReport(0, 50) }))) : (zteWebrtc.log("[setLocalVideoOpen falied]: localStream is null"), zteWebrtc.operationInMeeting.data = "localStream is null when setLocalVideoMuted", zteWebrtc.eventReport(1, 50)) }, setLocalVideoOpen: function () { var e = this; e.localStream ? (e.localVideoflag = !0, e.localStream.getVideoTracks().forEach((function (e) { e.enabled = !0, zteWebrtc.eventReport(0, 50) }))) : (zteWebrtc.operationInMeeting.data = "localStream is null when setLocalVideoOpen", zteWebrtc.eventReport(1, 50), zteWebrtc.log("[setLocalVideoOpen falied]: localStream is null")) }, setLocalVideoClose: function () { var e = this; return e.localStream ? (e.localVideoflag = !1, e.localStream.getVideoTracks().forEach((function (e) { e.enabled = !1, zteWebrtc.eventReport(0, 50) })), 0) : (zteWebrtc.operationInMeeting.data = "localStream is null when setLocalVideoClose", zteWebrtc.eventReport(1, 50), zteWebrtc.log("[setLocalVideoClose falied]: localStream is null"), -1) }, setLocalAudioClose: function () { return this.localStream ? (this.localStream.getAudioTracks().forEach((function (e) { e.enabled = !1, zteWebrtc.eventReport(0, 50) })), 0) : (zteWebrtc.log("[setLocalVideoOpen falied]: localStream is null"), zteWebrtc.operationInMeeting.data = "localStream is null when setLocalAudioMuted", zteWebrtc.eventReport(1, 50), -1) }, setRemoteAudioMuted: function () { this.remoteStream && this.remoteStream.getAudioTracks().forEach((function (e) { e.enabled = !e.enabled })) }, setCodec: function (e, t) { if (e) { const r = this.pc.getTransceivers()[t], i = r.receiver.track.kind; let n = this.getMimeTypes(e, i); this.setTransceiverCodec(r, n) } }, getMimeTypes: function (e, t) { let r = []; return e.split(";").forEach((function (e) { r.push(t + "/" + e) })), r }, setTransceiverCodec: function (e, t) { const r = e.receiver.track.kind; let i = RTCRtpSender.getCapabilities(r).codecs, n = RTCRtpReceiver.getCapabilities(r).codecs; i = this.preferCodec(i, t), n = this.preferCodec(i, t); let o = zteUtils.arrayConcat_pc(i, n); e.setCodecPreferences(o) }, preferCodec: function (e, t) { let r = [], i = []; return e.forEach((function (e) { t.forEach((function (t) { e.mimeType === t || e.mimeType.indexOf("fec") > -1 || e.mimeType.indexOf("rtx") > -1 || e.mimeType.indexOf("red") > -1 ? i.push(e) : r.push(e) })) })), i }, getSubImgStream: function () { var e = document.createElement("canvas"); this.canvasWidth && this.canvasHeight ? (e.width = this.canvasWidth, e.height = this.canvasHeight) : zteWebrtc.subTag.clientHeight && zteWebrtc.subTag.clientWidth ? (e.width = zteWebrtc.subTag.clientWidth, e.height = zteWebrtc.subTag.clientHeight, this.canvasWidth = zteWebrtc.subTag.clientWidth, this.canvasHeight = zteWebrtc.subTag.clientHeight) : zteWebrtc.subTag.scrollHeight && zteWebrtc.subTag.scrollWidth ? (e.width = zteWebrtc.subTag.scrollWidth, e.height = zteWebrtc.subTag.scrollHeight, this.canvasWidth = zteWebrtc.subTag.scrollWidth, this.canvasHeight = zteWebrtc.subTag.scrollHeight) : zteWebrtc.subTag.offsetHeight && zteWebrtc.subTag.offsetWidth ? (e.width = zteWebrtc.subTag.offsetWidth, e.height = zteWebrtc.subTag.offsetHeight, this.canvasWidth = zteWebrtc.subTag.offsetWidth, this.canvasHeight = zteWebrtc.subTag.offsetHeight) : (e.width = 1920, e.height = 1080); var t = e.getContext("2d"); t.fillStyle = "#00", t.fillRect(0, 0, e.width, e.height), this.subImgStream = e.captureStream() }, flushSubVideo: function (e = !1) { var t = this; zteWebrtc.subTag ? (t.getSubImgStream(), 0 == e ? (zteWebrtc.subTag.srcObject = null, zteWebrtc.subTag.srcObject = t.remoteSubStream, zteWebrtc.subTag.load(), console.log("flushSubVideo.hasSub1:", e)) : (zteWebrtc.subTag.srcObject = null, zteWebrtc.subTag.srcObject = t.subImgStream, zteWebrtc.subTag.load(), setTimeout((() => { zteWebrtc.subTag.srcObject = null, zteWebrtc.subTag.srcObject = t.remoteSubStream, zteWebrtc.subTag.load(), console.log("flushSubVideo. replace subImage to remoteSubStream.") }), 2e3), console.log("flushSubVideo.hasSub2:", e, "show subImage.")), console.log("flushSubVideo.hasSub2:", e)) : console.error("flushSubVideo.subTag is null.") } }, o = new webrtcPeerConnection, void 0 === (n = function () { return o }.call(t, r, t, e)) || (e.exports = n) }, 363: (e, t, r) => { var i; const n = { setSDP: function (e, t, r) { return e = this.setContentMain(e), r.enabled && (e = this.setContentSlides(e)), e = this.setMainVideoFmtp(e, t.video.resolution, t.video.framerate, t.video.rate), e = this.setMediaBitrate(e, "audio", t.audio.rate), e = this.setMediaBitrate(e, "video", t.video.rate, 1), r.enabled && (e = this.setSlidesVideoFmtp(e, r.resolution, r.framerate, r.rate), e = this.setMediaBitrate(e, "video", r.rate, 2)), e = this.setRtxTime(e), this.setCname(e) }, setExp: function (e) { let t = e.split("\n"), r = []; for (let e = 0; e < t.length; e++)-1 === t[e].indexOf("a=extmap") && r.push(t[e]); return r.join("\n") }, setSendrecv: function (e) { return e.replace(/a=recvonly/g, "a=sendrecv") }, setMainVideoFmtp: function (e, t, r, i) { if (!t) return e; let n = webrtcConfig.resolution[t].maxFs, o = "max-mbps=" + n * r + ";max-fs=" + n + ";max-br=" + i, a = e.split("\n"); for (let e = 0; e < a.length && 0 !== a[e].indexOf("a=content:slides"); e++)if (0 === a[e].indexOf("a=fmtp:") && -1 != a[e].indexOf("profile-level-id")) { if (-1 != a[e].indexOf("=64") && !zteWebrtc.HPCodeAbility) { let t = a[e].split("profile-level-id="); zteWebrtc.HPCodeAbility = t[1].substring(0, 6), a[e] = t[0] + "profile-level-id=" + t[1] } a[e] = a[e].replace(/\r/g, ""), a[e] = a[e] + ";" + o + "\r" } return a.join("\n") }, setSlidesVideoFmtp: function (e, t, r, i) { if (!t) return e; let n = webrtcConfig.resolution[t].maxFs, o = "max-mbps=" + n * r + ";max-fs=" + n + ";max-br=" + i, a = e.split("\n"), s = -1; for (let e = 0; e < a.length; e++)0 === a[e].indexOf("a=content:slides") && (s = e); if (-1 == s) return zteWebrtc.log("no slides when set video fmtp"), a.join("\n"); for (let e = s; e < a.length; e++)0 === a[e].indexOf("a=fmtp:") && -1 != a[e].indexOf("profile-level-id") && (a[e] = a[e].replace(/\r/g, ""), a[e] = a[e] + ";" + o + "\r"); return a.join("\n") }, setMediaBitrate: function (e, t, r, i) { let n = e.split("\n"), o = -1, a = 0; for (let e = 0; e < n.length; e++)if (0 === n[e].indexOf("m=" + t) && (a++, a === i)) { o = e; break } if (-1 === o) return e; for (o++; 0 === n[o].indexOf("i=") || 0 === n[o].indexOf("c=");)o++; if (0 === n[o].indexOf("b")) return n[o] = "b=AS:" + r + "\r", n.join("\n"); let s = n.slice(0, o); return s.push("b=AS:" + r + "\r"), s = s.concat(n.slice(o, n.length)), s.join("\n") }, setContentMain: function (e) { let t = e.split("\n"), r = -1; for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("m=video")) { r = e; break } if (-1 === r) return e; for (r++; 0 === t[r].indexOf("i=") || 0 === t[r].indexOf("c=") || 0 === t[r].indexOf("b=");)r++; let i = t.slice(0, r); return i.push("a=content:main\r"), i = i.concat(t.slice(r, t.length)), i.join("\n") }, setContentSlides: function (e) { let t = e.split("\n"), r = -1, i = 0; for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("m=video")) { if (1 === i) { r = e; break } i++ } if (-1 === r) return e; for (r++; 0 === t[r].indexOf("i=") || 0 === t[r].indexOf("c=") || 0 === t[r].indexOf("b=");)r++; let n = t.slice(0, r); return n.push("a=content:slides\r"), n = n.concat(t.slice(r, t.length)), n.join("\n") }, setRtxTime: function (e) { let t = e.split("\n"); for (let e = 0; e < t.length; e++)0 === t[e].indexOf("a=fmtp:") && -1 != t[e].indexOf("apt") && (t[e] = t[e].replace(/\r/g, ""), t[e] = t[e] + ";rtx-time=3000\r"); return t.join("\n") }, setCname: function (e) { let t = e.split("\n"); for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("a=ssrc") && -1 != t[e].indexOf("cname") && -1 != t[e].indexOf("/")) { let r = t[e].indexOf("cname") + 6, i = t[e].slice(r).replace("/", "0"); t[e] = t[e].slice(0, r) + i } return t.join("\n") }, setSendrecv: function (e) { return e.replace(/a=recvonly/g, "a=sendrecv") }, setSimulcast: function (e) { let t = e.split("\n"), r = -1, i = 0; for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("m=video")) { if (1 === i) { r = e; break } i++ } if (-1 === r) return e; let n = t.slice(0, r - 9); return n.push("a=ssrc-group:SIM 2178216979 2295769805 636898760\r"), n.push("a=ssrc-group:FID 2178216979 2643517961\r"), n.push("a=ssrc-group:FID 2295769805 1534787773\r"), n.push("a=ssrc-group:FID 636898760 1305495962\r"), n.push("a=ssrc:2178216979 cname:localCname\r"), n.push("a=ssrc:2178216979 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n.push("a=ssrc:2295769805 cname:localCname\r"), n.push("a=ssrc:2295769805 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n.push("a=ssrc:636898760 cname:localCname\r"), n.push("a=ssrc:636898760 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n.push("a=ssrc:2643517961 cname:localCname\r"), n.push("a=ssrc:2643517961 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n.push("a=ssrc:1534787773 cname:localCname\r"), n.push("a=ssrc:1534787773 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n.push("a=ssrc:1305495962 cname:localCname\r"), n.push("a=ssrc:1305495962 msid:R6WoG3JzZEw8BVEBuy1XpTuUzzfSGIlr08Ro 541b12bc-754c-4c06-8367-481ec12e3192\r"), n = n.concat(t.slice(r, t.length)), n.join("\n") }, changeProfileLevelId: function (e) { let t = e.split("\n"); for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("a=fmtp:") && -1 != t[e].indexOf("profile-level-id") && -1 != t[e].indexOf("=64")) { let r = t[e].split("profile-level-id="), i = r[1].substring(6, r[1].length); t[e] = r[0] + "profile-level-id=" + zteWebrtc.HPCodeAbility + i } return t.join("\n") }, setIosSafari: function (e) { let t = navigator.userAgent.indexOf("CPU iPhone OS "), r = navigator.userAgent.indexOf("like Mac OS"), i = webrtcConfig.safariSDP; if (-1 == t || -1 == r || !i) return e; let n = navigator.userAgent.substring(14 + t, r - 1); if (i.indexOf(n) < 0) return e; let o = e.split("\r\n"), a = []; for (let e = 0; e < o.length; e++) { var s = o[e]; -1 != s.indexOf("a=mid:1") ? s = "a=mid:1\r\na=extmap:13 urn:3gpp:video-orientation" : -1 != s.indexOf("a=mid:2") && (s = "a=mid:2\r\na=extmap:13 urn:3gpp:video-orientation"), a.push(s) } return a.join("\r\n") }, dealWithPacketizationMode: function (e) { var t = e.split("\n"); for (let e = 0; e < t.length; e++)if (0 === t[e].indexOf("a=fmtp:") && -1 != t[e].indexOf("profile-level-id") && -1 == t[e].indexOf("packetization-mode")) { let r = t[e].split(" "); r[0] = r[0] + " level-asymmetry-allowed=1;packetization-mode=1;", t[e] = r[0] + r[1] } return t.join("\n") } }; void 0 === (i = function () { return n }.call(t, r, t, e)) || (e.exports = i) }, 533: (e, t, r) => { var i, n, o; (n = function () { this.token = null, this.extendInfo = null, this.sipNo = null, this.wssUrl = null, this.heartbeatTime = 2e4, this.sipPwd = "", this.registerTo = "", this.connectTimeout = 2e3, this.socket = null, this.reconnectFlag = !1, this.lockReconnect = !1, this.reconnectCount = 0, this.heartbeatCount = 0, this.heartbeatInterval = null, this.calledJson = null, this.callNo = null, this.authData = null, this.candidatesOnQueue = [], this.transactionID = 0, this.connectionCheckFlag = !1, this.udpStatus = 0, this.tcpStatus = 1, this.pcUdp = null, this.pcTcp = null, this.checkTimeout = 1e4, this.registerCallid = null }).prototype = { init: function (e, t, r, i, n, o, a, s) { var c = this; c.close(), c.registerCallid = zteUtils.generateUUID(), c.wssUrl = i, c.sipNo = t, c.sipPwd = r, c.token = e, n && (c.heartbeatTime = n), o && (c.registerTo = o), a && (c.connectTimeout = a), s && (s.connectionCheckFlag && (c.connectionCheckFlag = s.connectionCheckFlag), s.checkTimeout && (c.checkTimeout = s.checkTimeout)), c.extendInfo = s; try { c.socket = new WebSocket(c.wssUrl) } catch (e) { zteWebrtc.log(e), zteWebrtc.registerFailedDeal(6); let t = "register", r = "single_register_websocketConnectException", i = "no", n = "end", o = zteWebrtc.constructAndDealSignalNode(t, r, i, n); if (0 != o) return void zteWebrtc.log("the result of signal deal is " + o) } window.setTimeout((function () { c.socket && 1 !== c.socket.readyState && (c.close(), zteWebrtc.publishEvent("onRegister", [1, "websocket connect fail"])) }), c.connectTimeout), c.socket.onopen = function (e) { c.onOpen(e) }, c.socket.onclose = function (e) { c.onClose(e) }, c.socket.onerror = function (e) { c.onError(e) }, c.socket.onmessage = function (e) { c.onMessage(e) } }, onOpen: function (e) { var t = this; let r = null; r = t.token ? "single_registerForSignAuth_afterWebsocketConnect" : "single_register_afterWebsocketConnect"; let i = zteWebrtc.constructAndDealSignalNode("register", r, "no", "end"); 0 == i ? (zteWebrtc.log("[webrtcWS] websocket open", "info"), t.reconnectFlag = !0, t.reconnectCount = 0, t._failedHeartbeatCount = 0, !0 === t.connectionCheckFlag ? (t.tcpStatus = 1, t.udpStatus = 1, t.connectcheck()) : t.register()) : zteWebrtc.log("[WS.onOpen]the result of signal deal is " + i) }, onClose: function (e) { let t = zteWebrtc.constructAndDealSignalNode("register", "single_register_websocketConnectClose", "no", "end"); 0 == t ? (zteWebrtc.registerFailedDeal(4), zteWebrtc.log("[webrtcWS] websocket close", "info"), zteWebrtc.log(e, "info"), this.stopHeartbeat(), this.reconnect()) : zteWebrtc.log("the result of signal deal is " + t) }, onError: function (e) { let t = zteWebrtc.constructAndDealSignalNode("register", "single_register_websocketConnectError", "no", "end"); 0 == t ? (zteWebrtc.registerFailedDeal(5), zteWebrtc.log("[webrtcWS] websocket error", "info"), zteWebrtc.log(e, "info"), this.stopHeartbeat(), this.reconnect()) : zteWebrtc.log("the result of signal deal is " + t) }, onMessage: function (e) { var t = this, r = JSON.parse(e.data); switch (t.log_(r), r.Method) { case "REGISTER": if (0 === t.heartbeatCount) if (200 === r.StatusCode) { if (signalType = "register", currentSignalStatus = "single_register_afterReceive200", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.registerState = 1, t._failedHeartbeatCount = 0, zteWebrtc.publishEvent("onRegister", [0, "success", t.udpStatus]), webrtcPFM.bootmessage(), t.startHeartbeat() } else if (401 === r.StatusCode) { signalType = "register", currentSignalStatus = "single_register_afterReceive401", expectedSignalStatus = "single_register_beforeSendAuth", signalStausCode = "middleOfExternal"; let e = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode); if (0 != e) return void zteWebrtc.log("the result of signal deal is " + e); t.authData = t.getAuthData(r["WWW-Authenticate"], t.token, t.registerTo), t.authReg() } else if (409 === r.StatusCode) zteWebrtc.publishEvent("onRegister", [2, "already login"]); else { if (signalType = "register", currentSignalStatus = "single_register_notAnyDesiredState", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); t.close(), zteWebrtc.publishEvent("onRegister", [2, "login fail"]) } else if (200 === r.StatusCode) { if (signalType = "register", currentSignalStatus = "single_register_afterReceive200", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.registerState = 1, t._failedHeartbeatCount = 0, t.startHeartbeat(), zteWebrtc.log("[webrtcWS] SGW ===>> SDK:  heartbeat~~~ NO." + t.heartbeatCount, "info") } else if (401 === r.StatusCode) { if (signalType = "register", currentSignalStatus = "single_register_afterReceive401", expectedSignalStatus = "single_register_beforeSendAuth", signalStausCode = "middleOfExternal", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); t.authData = t.getAuthData(r["WWW-Authenticate"], t.token, t.registerTo), t.authReg() } else { if (signalType = "register", currentSignalStatus = "single_register_notAnyDesiredState", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.log("[webrtcWS] SGW ===>> SDK:  heartbeat fail~~~ NO." + t.heartbeatCount, "error"), (480 == r.StatusCode || ++t._failedHeartbeatCount > 3) && (t.close(), zteWebrtc.publishEvent("onUnRegister", [480 == r.StatusCode ? 0 : 1, "heartbeat fail, " + r.StatusCode])) } break; case "UNREGISTER": if (signalType = "unRegister", currentSignalStatus = "single_unRegister_afterReceiveUNREGISTER", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("onUnRegister", [0, "unregister success, status:" + r.StatusCode]), t.close(); break; case "INVITE": if (signalType = "call", currentSignalStatus = "single_answer_afterReceiveINVITE", expectedSignalStatus = "single_answer_beforeSend180", signalStausCode = "start", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); t.calledJson = r, r && r.CsID && (zteWebrtc.CsID = r.CsID), t.callNo = r.From, window.RTCPeerConnection ? null == webrtcPC.pc && webrtcPC.createPeerConnection() : zteWebrtc.log("[WEBRTC] RTCPeerConnection: create PeerConnection fail", "error"), t.ringing(r), zteWebrtc.publishEvent("onRinging", [1, r.From, t.sipNo, r.CallID, ""]); let e = t.paraMeetingNumber(r); null != e && zteWebrtc.publishEvent("onCalling", [0, e]), t.inviteTime = new Date, webrtcPFM.event(1); break; case "REINVITE": t.calledJson = r, webrtcPC.reset(); let n = t.paraMeetingNumber(r); null != n && zteWebrtc.publishEvent("onCalling", [0, n]), t.answer(webrtcPC.mediaParam, webrtcPC.slidesParam); break; case "ACK": if (signalType = "call", currentSignalStatus = "signal_answer_afterReceiveACK", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteUtils.isEmpty(r.SDP) ? (zteWebrtc.callStatus = 1, zteWebrtc.eventReport(0, 40), zteWebrtc.publishEvent("onTalking", [r.From, t.sipNo, r.CallID, ""])) : (r.SDP = webrtcSDP.setIosSafari(r.SDP), webrtcPC.pc.setRemoteDescription(new RTCSessionDescription({ type: "answer", sdp: r.SDP })).then((() => { zteWebrtc.callStatus = 1, zteWebrtc.eventReport(0, 40), zteWebrtc.publishEvent("onRemoteStream", [t.remoteStream]), zteWebrtc.publishEvent("onTalking", [t.sipNo, r.From, r.CallID, ""]), zteWebrtc.log("[webrtcPC] : setRemoteDescription from answer success", "info") })).catch((e => { t.releaseCall(), zteWebrtc.makecallFailedDeal(15), zteWebrtc.log("[webrtcPC] : setRemoteDescription from answer fail, msg:" + e.message, "error") })), zteWebrtc.publishEvent("onRemoteStream", [t.remoteStream])); break; case "BYE": if (signalType = "call", currentSignalStatus = "signal_answer_afterReceiveBYE", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.operationInMeeting.operation = 72, zteWebrtc.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), webrtcPC.closePeerConnection(!0), zteWebrtc.resetStatus(), zteWebrtc.publishEvent("onRelease", [r.From, t.sipNo, r.CallID, ""]), t.resbye(r), webrtcPFM.event(2), zteWebrtc.eventReport(0, 50); break; case "RES BYE": webrtcPC.closePeerConnection(!0), zteWebrtc.resetStatus(), zteWebrtc.publishEvent("onRelease", [t.sipNo, r.From, r.CallID, ""]), zteWebrtc.eventReport(0, 50); break; case "RES": if (200 == r.StatusCode && r.Cseq) { if (signalType = "audioAndVideoSwitch", currentSignalStatus = "single_audioAndVideoSwitch_afterReceive200", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("switchAudioAndVideo", [0, r.Cseq]), "101" == r.Cseq ? zteWebrtc.localVideoOpenFlag && zteWebrtc.setLocalVideoClose() : zteWebrtc.localVideoOpenFlag && zteWebrtc.setLocalVideoOpen() } else if (200 != r.StatusCode && r.Cseq) { if (signalType = "audioAndVideoSwitch", currentSignalStatus = "single_audioAndVideoSwitch_afterReceiveElse", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.videoFlag ? zteWebrtc.videoFlag = !1 : zteWebrtc.videoFlag = !0, zteWebrtc.operationInMeeting.data = "status is not 200, the status code is " + r.StatusCode, zteWebrtc.eventReport(1, 50), zteWebrtc.publishEvent("switchAudioAndVideo", [1, r.Cseq]) } else if (180 == r.StatusCode) { if (signalType = "call", currentSignalStatus = "single_makecall_afterReceive180", expectedSignalStatus = "single_makecall_afterReceive200", signalStausCode = "middleOfExternal", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("onRinging", [2, t.sipNo, r.From, r.CallID, ""]) } else if (200 == r.StatusCode) { if (signalType = "call", currentSignalStatus = "single_makecall_afterReceive200", expectedSignalStatus = "single_makecall_beforeSendACK", signalStausCode = "middleOfExternal", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("onAnswering", [2, t.sipNo, r.From, r.CallID, ""]); let e = t.paraMeetingNumber(r); null != e && zteWebrtc.publishEvent("onCalling", [0, e]), zteUtils.isEmpty(r.SDP) || (r.SDP = webrtcSDP.changeProfileLevelId(r.SDP), r.SDP = webrtcSDP.setIosSafari(r.SDP), r.SDP = webrtcSDP.dealWithPacketizationMode(r.SDP), webrtcPC.pc.setRemoteDescription(new RTCSessionDescription({ type: "answer", sdp: r.SDP })).then((() => { zteWebrtc.publishEvent("onRemoteStream", [t.remoteStream]), t.ack(r), zteWebrtc.callStatus = 1, zteWebrtc.eventReport(0, 40), zteWebrtc.publishEvent("onTalking", [t.sipNo, r.From, r.CallID, ""]), webrtcPFM.event(1), zteWebrtc.log("[webrtcPC] : setRemoteDescription from answer success", "info"), t.candidatesOnQueue.length > 0 && t.candidatesOnQueue.forEach((function (e) { webrtcPC.pc.addIceCandidate(e).catch((e => { })) })) })).catch((e => { t.releaseCall(), zteWebrtc.makecallFailedDeal(15), zteWebrtc.log("[webrtcPC] : setRemoteDescription from answer fail, msg:" + e.message, "error") }))) } else { if (signalType = "call", currentSignalStatus = "single_makecall_ReceiveElse", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); t.releaseCall(), zteWebrtc.makecallFailedDeal(17) } break; case "FLOOR STATUS": 3 == r.StatusCode && (webrtcPC.flushSubVideo(!0), zteWebrtc.recvSunState = 1, zteWebrtc.publishEvent("onRecvSubStatus", [1]), zteWebrtc.sendSlidesFlag ? zteWebrtc.log("you have sended the slides, ignore the FLOOR STATUS CODE") : (zteWebrtc.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), zteWebrtc.operationInMeeting.operation = 66, zteWebrtc.eventReport(0, 50), zteWebrtc.floorTokenHoldStatus = 2)), 5 != r.StatusCode && 6 != r.StatusCode && 7 != r.StatusCode || (zteWebrtc.sendSlidesFlag || (zteWebrtc.floorTokenHoldStatus = 0), webrtcPC.flushSubVideo(!1), zteWebrtc.recvSunState = 0, zteWebrtc.publishEvent("onRecvSubStatus", [0])); break; case "FLOOR REQUEST STATUS": if (2 == r.StatusCode && (signalType = "shareInSub", currentSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_2", expectedSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_1", signalStausCode = "middleOfExternal", zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode)), 1 == r.StatusCode && (signalType = "shareInSub", currentSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_1", expectedSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_3", signalStausCode = "middleOfExternal", zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode)), 3 == r.StatusCode) { if (zteWebrtc.floorTokenHoldStatus = 1, signalType = "shareInSub", currentSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_3", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return zteWebrtc.stopShareInSub(), void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("onBFCP", [1]) } if (4 == r.StatusCode) { if (signalType = "shareInSub", currentSignalStatus = "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_4", expectedSignalStatus = "no", signalStausCode = "end", res = zteWebrtc.constructAndDealSignalNode(signalType, currentSignalStatus, expectedSignalStatus, signalStausCode), 0 != res) return void zteWebrtc.log("the result of signal deal is " + res); zteWebrtc.publishEvent("onBFCP", [0]) } 7 == r.StatusCode && zteWebrtc.publishEvent("offBFCP", [1]), 5 != r.StatusCode && 6 != r.StatusCode || (zteWebrtc.floorTokenHoldStatus = 0, zteWebrtc.publishEvent("offBFCP", [1])); break; case "CANDIDATE": var i = new RTCIceCandidate({ sdpMLineIndex: r.label, candidate: r.candidate }); t.candidatesOnQueue.push(i), webrtcPC.pc.addIceCandidate(i).then().catch((e => zteWebrtc.log("[webrtcPC] : addIceCandidate fail, msg:" + e.message, "warn"))); break; case "CONNECTCHECEK RES": if (200 == r.StatusCode) { let e = { iceServers: [] }; if (t.pcTcp = new RTCPeerConnection(e), t.pcUdp = new RTCPeerConnection(e), zteUtils.isEmpty(r.ConnectSdp)) { zteWebrtc.publishEvent("onRegister", [2, "[webrtcWS] websocket recv SDP is empty"]), zteWebrtc.registerFailedDeal(8); break } if (zteUtils.isEmpty(r.UDPCandiate)) { zteWebrtc.publishEvent("onRegister", [2, "[webrtcWS] websocket recv UDPCandiate is empty"]), zteWebrtc.registerFailedDeal(9); break } if (zteUtils.isEmpty(r.TCPCandiate)) { zteWebrtc.publishEvent("onRegister", [2, "[webrtcWS] websocket recv TCPCandiate is empty"]), zteWebrtc.registerFailedDeal(10); break } t.pcTcp.oniceconnectionstatechange = function (e) { switch (t.pcTcp.iceConnectionState) { case "completed": case "connected": zteWebrtc.log("tcp is connect sucess", "info"), t.tcpStatus = 0 } }, t.pcUdp.oniceconnectionstatechange = function (e) { switch (t.pcUdp.iceConnectionState) { case "completed": case "connected": zteWebrtc.log("udp is connect sucess", "info"), t.udpStatus = 0 } }; let i = { sdp: r.ConnectSdp, type: "offer" }, n = new RTCIceCandidate({ candidate: r.TCPCandiate, sdpMLineIndex: 0, sdpMid: "0" }), o = new RTCIceCandidate({ candidate: r.UDPCandiate, sdpMLineIndex: 0, sdpMid: "0" }); t.pcTcp.setRemoteDescription(i).then((() => { t.pcTcp.createAnswer().then((e => { t.pcTcp.setLocalDescription(e).then((() => { zteWebrtc.log("[webrtcPC] :pcTcp setLocalDescription from answer success", "info"), t.pcTcp.addIceCandidate(n).then((() => { zteWebrtc.log("pcTcp addIceCandidate sucess", "info") })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "Error:pcTcp Failure during addIceCandidate()" + e.message]), zteWebrtc.registerFailedDeal(14) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcTcp setLocalDescription from answer fail, msg:" + e.message]), zteWebrtc.registerFailedDeal(13) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcTcp Create Answer Error"]), zteWebrtc.registerFailedDeal(12) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcTcp setRemoteDescription from answer fail, msg:" + e.message]), zteWebrtc.registerFailedDeal(11) })), t.pcUdp.setRemoteDescription(i).then((() => { t.pcUdp.createAnswer().then((e => { t.pcUdp.setLocalDescription(e).then((() => { zteWebrtc.log("[webrtcPC] :pcUdp setLocalDescription from answer success", "info"), t.pcUdp.addIceCandidate(o).then((() => { zteWebrtc.log("pcUdp addIceCandidate sucess", "info") })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "Error:pcUdp Failure during addIceCandidate()" + e.message]), zteWebrtc.registerFailedDeal(18) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcUdp setLocalDescription from answer fail, msg:" + e.message]), zteWebrtc.registerFailedDeal(17) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcUdp Create Answer Error"]), zteWebrtc.registerFailedDeal(16) })) })).catch((e => { zteWebrtc.publishEvent("onRegister", [2, "[webrtcPC] :pcUdp setRemoteDescription from answer fail, msg:" + e.message]), zteWebrtc.registerFailedDeal(15) })), window.setTimeout((function () { t.pcTcp && (t.pcTcp.close(), t.pcTcp = null), t.pcUdp && (t.pcUdp.close(), t.pcUdp = null), t.register() }), t.checkTimeout) } else zteWebrtc.publishEvent("onRegister", [2, "[webrtcWS] websocket recv StatusCode is error"]), zteWebrtc.registerFailedDeal(7) } }, log: function (e) { var t = JSON.stringify(e); if (zteUtils.isEmpty(e.SDP)) zteWebrtc.log("[webrtcWS] SDK ===>> SGW : " + t, "info"); else { var r = { ...e }; r.SDP = "..."; var i = JSON.stringify(r); zteWebrtc.log("[webrtcWS] SDK ===>> SGW : " + i, "info"), zteWebrtc.log("[SDP]" + e.SDP, "info"), zteWebrtc.localSDP = e.SDP } }, log_: function (e) { var t = JSON.stringify(e); if (zteUtils.isEmpty(e.SDP)) zteWebrtc.log("[webrtcWS] SGW ===>> SDK : " + t, "info"); else { var r = { ...e }; r.SDP = "..."; var i = JSON.stringify(r); zteWebrtc.log("[webrtcWS] SGW ===>> SDK : " + i, "info"), zteWebrtc.log("[SDP]" + e.SDP, "info"), zteWebrtc.remoteSDP = e.SDP, zteUtils.parseSDP(e.SDP) } }, send: function (e) { var t = this, r = JSON.stringify(e); try { t.socket ? t.socket.send(r) : zteWebrtc.log("socket is null", "error"), t.log(e) } catch (e) { zteWebrtc.log(e, "error") } }, register: function () { var e = this; if (e.token) { let e = "register", t = "single_register_beforeSendRegister", r = "single_register_afterReceive401", i = "start", n = zteWebrtc.constructAndDealSignalNode(e, t, r, i); if (0 != n) return void zteWebrtc.log("the result of signal deal is " + n) } else { let e = "register", t = "single_register_beforeSendRegister", r = "single_register_afterReceive200", i = "start", n = zteWebrtc.constructAndDealSignalNode(e, t, r, i); if (0 != n) return void zteWebrtc.log("the result of signal deal is " + n) } if (1 == e.udpStatus && 1 == e.tcpStatus) zteWebrtc.publishEvent("onRegister", [2, "register fail, status: can not connect webrtc mgw!"]), zteWebrtc.registerFailedDeal(19); else { var t = { Method: "REGISTER", From: e.sipNo, To: e.registerTo, connecttype: e.udpStatus, CallID: e.registerCallid, WebsktTime: e.heartbeatTime / 1e3, StreamType: zteWebrtc.streamType }; e.send(t) } }, authReg: function () { var e = this; let t = zteWebrtc.constructAndDealSignalNode("register", "single_register_beforeSendAuth", "single_register_afterReceive200", "middleOfExternal"); if (0 == t) { var r = { Method: "REGISTER", From: e.sipNo, To: e.registerTo, connecttype: e.udpStatus, CallID: e.registerCallid, WebsktTime: e.heartbeatTime / 1e3, StreamType: zteWebrtc.streamType, Authorization: e.authData }; e.send(r) } else zteWebrtc.log("the result of signal deal is " + t) }, invite_: function (e) { var t = this; let r = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_beforeSendINVITE", "single_makecall_afterReceive180", "middleOfExternal"); if (0 == r) { var i = zteUtils.generateUUID(), n = { Method: "INVITE", From: t.sipNo, To: t.callNo, CallID: i, SDP: e, Cseq: "100", CsID: zteWebrtc.CsID }; t.send(n) } else zteWebrtc.log("the result of signal deal is " + r) }, ringing: function (e) { let t = zteWebrtc.constructAndDealSignalNode("call", "single_answer_beforeSend180", "no", "end"); if (0 == t) { var r = { Method: "RES", StatusCode: "180 Ringing", From: this.sipNo, To: e.From, CallID: e.CallID, CsID: zteWebrtc.CsID }; this.send(r) } else zteWebrtc.log("the result of signal deal is " + t) }, answer_: function (e, t) { let r = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_beforeSend200OK", "signal_answer_afterReceiveACK", "middleOfExternal"); if (0 == r) { var i = { Method: "RES", StatusCode: "200 OK", From: this.sipNo, To: e.From, CallID: e.CallID, SDP: t, CsID: zteWebrtc.CsID }; this.send(i) } else zteWebrtc.log("the result of signal deal is " + r) }, candidate: function (e) { var t = this, r = { Method: "CANDIDATE", From: t.sipNo, To: t.callNo, SDP: e.candidate.candidate, id: e.candidate.sdpMid, label: e.candidate.sdpMLineIndex, candidate: e.candidate.candidate, CsID: zteWebrtc.CsID }; t.send(r) }, ack: function (e) { let t = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_beforeSendACK", "no", "end"); if (0 == t) { var r = { Method: "ACK", From: this.sipNo, To: e.From, CsID: zteWebrtc.CsID }; this.send(r) } else zteWebrtc.log("the result of signal deal is " + t) }, bye: function () { var e = this, t = { Method: "BYE", From: e.sipNo, To: e.callNo, CallID: e.callid, CsID: zteWebrtc.CsID }; e.send(t); let r = zteWebrtc.constructAndDealSignalNode("call", "single_releaseCall_afterSendBYE", "no", "end"); 0 == r || zteWebrtc.log("the result of signal deal is " + r) }, resbye: function (e) { var t = { Method: "RES BYE", StatusCode: "200 OK", From: this.sipNo, To: e.From, CallID: e.CallID, CsID: zteWebrtc.CsID }; this.send(t) }, unRegister: function () { var e = this, t = { Method: "UNREGISTER", From: e.sipNo, To: e.registerTo }; e.send(t), e.stopHeartbeat() }, count: function () { return this.transactionID = this.transactionID + 1 }, getSubStreamToken: function () { var e = this, t = { Method: "FLOORREQUEST", From: e.sipNo, To: e.registerTo, transactionID: e.count(), CsID: zteWebrtc.CsID }; let r = zteWebrtc.constructAndDealSignalNode("shareInSub", "single_shareInsub_beforeSendFLOORREQUEST", "single_shareInsub_afterReceiveFLOORREQUESTSTATUS_2", "middleOfExternal"); 0 == r ? e.send(t) : zteWebrtc.log("the result of signal deal is " + r) }, releaseSubStreamToken: function () { if (1 == zteWebrtc.floorTokenHoldStatus) { var e = this, t = { Method: "FLOORRELEASE", From: e.sipNo, To: e.registerTo, transactionID: e.count(), CsID: zteWebrtc.CsID }; e.send(t) } else zteWebrtc.log("you have no floor token, you need not release") }, invite: function (e, t, r) { var i = this; let n = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_beforeCreateOffer", "single_makecall_afterCreateOffer", "middleOfInternal"); 0 == n ? (i.inviteTime = new Date, i.callNo = e, webrtcPC.pc.createOffer().then((e => { e.sdp = webrtcSDP.setSDP(e.sdp, t, r); let n = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_afterCreateOffer", "single_makecall_afterSetLocalDescription", "middleOfInternal"); 0 == n ? webrtcPC.pc.setLocalDescription(e).then((() => { let t = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_afterSetLocalDescription", "single_makecall_beforeSendINVITE", "middleOfInternal"); 0 == t ? (zteWebrtc.log("[webrtcPC] : setLocalDescription from offer success", "info"), i.invite_(e.sdp)) : zteWebrtc.log("the result of signal deal is " + t) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_setLocalDescriptionFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(14), zteWebrtc.log("[webrtcPC] : setLocalDescription from offer fail, msg:" + e.message, "error")) : zteWebrtc.log("the result of signal deal is " + t) })) : zteWebrtc.log("the result of signal deal is " + n) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "single_makecall_createOfferFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(13), zteWebrtc.log("[webrtcPC] create offer error, msg:" + e.message, "error")) : zteWebrtc.log("the result of signal deal is " + t) }))) : zteWebrtc.log("the result of signal deal is " + n) }, answer: function (e, t) { var r = this, i = r.calledJson; if (zteUtils.isEmpty(i.SDP)) { let n = "call", o = "signal_answer_beforeCreateOffer", a = "signal_answer_afterCreateOffer", s = "start", c = zteWebrtc.constructAndDealSignalNode(n, o, a, s); if (0 != c) return void zteWebrtc.log("the result of signal deal is " + c); webrtcPC.pc.createOffer().then((n => { let o = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_afterCreateOffer", "signal_answer_afterSetLocalDescription", "middleOfExternal"); 0 == o ? (n.sdp = webrtcSDP.setSDP(n.sdp, e, t), webrtcPC.pc.setLocalDescription(n).then((() => { let e = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_afterSetLocalDescription", "signal_answer_beforeSend200OK", "middleOfExternal"); 0 == e ? (zteWebrtc.log("[webrtcPC] : setLocalDescription from offer success", "info"), r.answer_(i, n.sdp)) : zteWebrtc.log("the result of signal deal is " + e) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_setLocalDescriptionFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(26), zteWebrtc.log("[webrtcPC] : setLocalDescription from offer fail, msg:" + e.message, "warn")) : zteWebrtc.log("the result of signal deal is " + t) }))) : zteWebrtc.log("the result of signal deal is " + o) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_createOfferFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(28), zteWebrtc.log("[webrtcPC] create offer error, msg:" + e.message, "error")) : zteWebrtc.log("the result of signal deal is " + t) })) } else { let n = "call", o = "signal_answer_beforeSetRemoteDescription", a = "signal_answer_afterSetRemoteDescription", s = "start", c = zteWebrtc.constructAndDealSignalNode(n, o, a, s); if (0 != c) return void zteWebrtc.log("the result of signal deal is " + c); i.SDP = webrtcSDP.setIosSafari(i.SDP), i.SDP = webrtcSDP.dealWithPacketizationMode(i.SDP), webrtcPC.pc.setRemoteDescription(new RTCSessionDescription({ type: "offer", sdp: i.SDP })).then((() => { let n = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_afterSetRemoteDescription", "signal_answer_afterCreateAnswer", "middleOfExternal"); 0 == n ? (zteWebrtc.publishEvent("onRemoteStream", [r.remoteStream]), webrtcPC.addTransceiverLabel(webrtcPC.pc), r.candidatesOnQueue.length > 0 && r.candidatesOnQueue.forEach((function (e) { webrtcPC.pc.addIceCandidate(e).catch((e => { })) })), zteWebrtc.log("[webrtcPC] : setRemoteDescription from offer success", "info"), webrtcPC.pc.createAnswer().then((n => { let o = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_afterCreateAnswer", "signal_answer_afterSetLocalDescription", "middleOfExternal"); 0 == o ? (n.sdp = webrtcSDP.setSDP(n.sdp, e, t), webrtcPC.pc.setLocalDescription(n).then((() => { let e = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_afterSetLocalDescription", "signal_answer_beforeSend200OK", "middleOfExternal"); 0 == e ? (zteWebrtc.log("[webrtcPC] : setLocalDescription from answer success", "info"), r.answer_(i, n.sdp)) : zteWebrtc.log("the result of signal deal is " + e) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_setLocalDescriptionFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(24), zteWebrtc.log("[webrtcPC] : setLocalDescription from answer fail, msg:" + e.message, "error")) : zteWebrtc.log("the result of signal deal is " + t) }))) : zteWebrtc.log("the result of signal deal is " + o) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_createAnswerFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(23), zteWebrtc.log("[webrtcPC] : Create Answer Error", "error")) : zteWebrtc.log("the result of signal deal is " + t) }))) : zteWebrtc.log("the result of signal deal is " + n) })).catch((e => { let t = zteWebrtc.constructAndDealSignalNode("call", "signal_answer_setRemoteDescriptionFailed", "no", "end"); 0 == t ? (zteWebrtc.makecallFailedDeal(25), zteWebrtc.log("[webrtcPC] : setRemoteDescription from offer fail, msg:" + e.message, "error")) : zteWebrtc.log("the result of signal deal is " + t) })) } }, releaseCall: function () { var e = this, t = e.calledJson; e.bye(), zteWebrtc.callStatus = 0, webrtcPC.closePeerConnection(!0), zteWebrtc.resetStatus(), t ? zteWebrtc.publishEvent("onRelease", [e.sipNo, t.From, t.CallID, ""]) : zteWebrtc.publishEvent("onRelease", [e.sipNo, "", "", ""]), zteWebrtc.eventReport(0, 50), webrtcPFM.event(2) }, startHeartbeat: function () { var e = this; e.heartbeatInterval && window.clearInterval(e.heartbeatInterval), e.heartbeatInterval = window.setInterval((function () { e.heartbeatCount++, e.register() }), e.heartbeatTime) }, stopHeartbeat: function () { this.heartbeatInterval && window.clearInterval(this.heartbeatInterval) }, VideoToAudio: function () { var e = this; let t = zteWebrtc.constructAndDealSignalNode("audioAndVideoSwitch", "single_videoToAudio_beforeSendVideoToAudio", "single_audioAndVideoSwitch_afterReceive200", "start"); if (0 == t) { var r = { Method: "VideoToAudio", From: e.sipNo, To: e.registerTo, CallID: e.callid, Cseq: 101, CsID: zteWebrtc.CsID }; e.send(r) } else zteWebrtc.log("the result of signal deal is " + t) }, AudioToVideo: function () { var e = this; let t = zteWebrtc.constructAndDealSignalNode("audioAndVideoSwitch", "single_videoToAudio_beforeSendAudioToVideo", "single_audioAndVideoSwitch_afterReceive200", "start"); if (0 == t) { var r = { Method: "AudioToVideo", From: e.sipNo, To: e.registerTo, CallID: e.callid, Cseq: 102, CsID: zteWebrtc.CsID }; e.send(r) } else zteWebrtc.log("the result of signal deal is " + t) }, reconnect: function () { var e = this; if (e.reconnectCount >= 5) return zteWebrtc.publishEvent("onUnRegister", [1, "unregister success, status: websocket disconnected!"]), webrtcPC.closePeerConnection(!0), void e.close(); e.lockReconnect || e.reconnectFlag && (console.warn("WS reconnection..."), e.lockReconnect = !0, e.socket = null, window.setTimeout((function () { try { e.socket = new WebSocket(e.wssUrl) } catch (e) { console.log("reconnect WS error") } e.socket && (e.socket.onopen = function (t) { e.onOpen(t) }, e.socket.onclose = function (t) { e.onClose(t) }, e.socket.onerror = function (t) { e.onError(t) }, e.socket.onmessage = function (t) { e.onMessage(t) }), e.lockReconnect = !1, e.reconnectCount++ }), 2e3)) }, close: function () { console.log("WS close"), this.stopHeartbeat(), this.socket && this.socket.close(), this.socket = null, this.sipNo = null, this.wssUrl = null, this.heartbeatTime = 2e4, this.sipPwd = "", this.reconnectFlag = !1, this.lockReconnect = !1, this.reconnectCount = 0, zteWebrtc.registerState = 0, this.heartbeatCount = 0, this.calledJson = null, this.authData = null, this.registerTo = "", this.token = null, this.callNo = null, this._failedHeartbeatCount = 0 }, getAuthData: function (e, t, r) { let i = function (e) { let t = e.replace("Digest", "").replace(new RegExp(" ", "gm"), "").split(","); var r = {}; return t.forEach((function (e) { let t = e.indexOf("="), i = e.slice(0, t), n = e.slice(t + 1); n.startsWith('"') && n.endsWith('"') && (n = n.slice(1, -1)), r[i] = n })), r }(e), n = function (e) { let i = {}; return i.username = t, i.realm = e.realm, i.nonce = e.nonce, i.uri = "sip:" + r, i.response = md5(zteUtils.generateUUID()), i.algorithm = e.algorithm, i.cnonce = zteUtils.createHexRandom(16), i.qop = e.qop, i.nc = "00000001", i }(i), o = "Digest "; for (x in n) { let e = ""; e = "nc" == x || "stale" == x || "algorithm" == x ? x + "=" + n[x] + ", " : x + '="' + n[x] + '", ', o += e } return o = o.slice(0, -2), o }, paraPsp: function (e) { let t = e.indexOf("sip:"); if (-1 == t) return console.log("paraPsp can not find sip:"), null; let r = e.indexOf("@"); if (-1 == r) return console.log("paraPsp can not find @"), null; let i = e.slice(t + 4, r); return i.indexOf("*") > -1 ? i.split("*")[0] : i }, paraPai: function (e) { let t = e.indexOf("sip:"); if (-1 == t) return console.log("paraContact can not find sip:"), null; let r = e.indexOf("@"); if (-1 == r) return console.log("paraContact can not find @"), null; let i = e.slice(t + 4, r); return i.indexOf("*") > -1 ? i.split("*")[0] : i }, paraContact: function (e) { let t = e.indexOf("sip:"); if (-1 == t) return console.log("paraContact can not find sip:"), null; let r = e.indexOf("@"); if (-1 == r) return console.log("paraContact can not find @"), null; let i = e.slice(t + 4, r); return i.indexOf("*") > -1 ? i.split("*")[0] : i }, paraFrom: function (e) { let t = e.indexOf("sip:"); if (-1 == t) return console.log("paraFrom can not find sip:"), null; let r = e.indexOf("@"); if (-1 == r) return console.log("paraFrom can not find @"), null; let i = e.slice(t + 4, r); return i.indexOf("*") > -1 ? i.split("*")[0] : i }, paraMeetingNumber: function (e) { let t = null; return e.P_Service_Param && (t = this.paraPsp(e.P_Service_Param), null != t) || e.P_Asserted_Identity && (t = this.paraPai(e.P_Asserted_Identity), null != t) || e.Contact && (t = this.paraContact(e.Contact), null != t) || e.From && (t = this.paraFrom(e.From)), t }, connectcheck: function () { this.send({ Method: "CONNECTCHECEK" }) } }, o = new n, void 0 === (i = function () { return o }.call(t, r, t, e)) || (e.exports = i) }, 950: e => { e.exports = function e(t, r, i) { function n(a, s) { if (!r[a]) { if (!t[a]) { if (o) return o(a, !0); var c = new Error("Cannot find module '" + a + "'"); throw c.code = "MODULE_NOT_FOUND", c } var l = r[a] = { exports: {} }; t[a][0].call(l.exports, (function (e) { return n(t[a][1][e] || e) }), l, l.exports, e, t, r, i) } return r[a].exports } for (var o = void 0, a = 0; a < i.length; a++)n(i[a]); return n }({ 1: [function (e, t, r) { "use strict"; var i = (0, e("./adapter_factory.js").adapterFactory)({ window: "undefined" == typeof window ? void 0 : window }); t.exports = i }, { "./adapter_factory.js": 2 }], 2: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.adapterFactory = function () { var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).window, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }, r = i.log, l = i.detectBrowser(e), d = { browserDetails: l, commonShim: s, extractVersion: i.extractVersion, disableLog: i.disableLog, disableWarnings: i.disableWarnings, sdp: c }; switch (l.browser) { case "chrome": if (!n || !n.shimPeerConnection || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), d; if (null === l.version) return r("Chrome shim can not determine version, not shimming."), d; r("adapter.js shimming chrome."), d.browserShim = n, s.shimAddIceCandidateNullOrEmpty(e, l), n.shimGetUserMedia(e, l), n.shimMediaStream(e, l), n.shimPeerConnection(e, l), n.shimOnTrack(e, l), n.shimAddTrackRemoveTrack(e, l), n.shimGetSendersWithDtmf(e, l), n.shimGetStats(e, l), n.shimSenderReceiverGetStats(e, l), n.fixNegotiationNeeded(e, l), s.shimRTCIceCandidate(e, l), s.shimConnectionState(e, l), s.shimMaxMessageSize(e, l), s.shimSendThrowTypeError(e, l), s.removeExtmapAllowMixed(e, l); break; case "firefox": if (!o || !o.shimPeerConnection || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), d; r("adapter.js shimming firefox."), d.browserShim = o, s.shimAddIceCandidateNullOrEmpty(e, l), o.shimGetUserMedia(e, l), o.shimPeerConnection(e, l), o.shimOnTrack(e, l), o.shimRemoveStream(e, l), o.shimSenderGetStats(e, l), o.shimReceiverGetStats(e, l), o.shimRTCDataChannel(e, l), o.shimAddTransceiver(e, l), o.shimGetParameters(e, l), o.shimCreateOffer(e, l), o.shimCreateAnswer(e, l), s.shimRTCIceCandidate(e, l), s.shimConnectionState(e, l), s.shimMaxMessageSize(e, l), s.shimSendThrowTypeError(e, l); break; case "safari": if (!a || !t.shimSafari) return r("Safari shim is not included in this adapter release."), d; r("adapter.js shimming safari."), d.browserShim = a, s.shimAddIceCandidateNullOrEmpty(e, l), a.shimRTCIceServerUrls(e, l), a.shimCreateOfferLegacy(e, l), a.shimCallbacksAPI(e, l), a.shimLocalStreamsAPI(e, l), a.shimRemoteStreamsAPI(e, l), a.shimTrackEventTransceiver(e, l), a.shimGetUserMedia(e, l), a.shimAudioContext(e, l), s.shimRTCIceCandidate(e, l), s.shimMaxMessageSize(e, l), s.shimSendThrowTypeError(e, l), s.removeExtmapAllowMixed(e, l); break; default: r("Unsupported browser!") }return d }; var i = l(e("./utils")), n = l(e("./chrome/chrome_shim")), o = l(e("./firefox/firefox_shim")), a = l(e("./safari/safari_shim")), s = l(e("./common_shim")), c = l(e("sdp")); function l(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t } }, { "./chrome/chrome_shim": 3, "./common_shim": 6, "./firefox/firefox_shim": 7, "./safari/safari_shim": 10, "./utils": 11, sdp: 12 }], 3: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = e("./getusermedia"); Object.defineProperty(r, "shimGetUserMedia", { enumerable: !0, get: function () { return n.shimGetUserMedia } }); var o = e("./getdisplaymedia"); Object.defineProperty(r, "shimGetDisplayMedia", { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimMediaStream = function (e) { e.MediaStream = e.MediaStream || e.webkitMediaStream }, r.shimOnTrack = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get: function () { return this._ontrack }, set: function (e) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e) }, enumerable: !0, configurable: !0 }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var r = this; return this._ontrackpoly || (this._ontrackpoly = function (t) { t.stream.addEventListener("addtrack", (function (i) { var n; n = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find((function (e) { return e.track && e.track.id === i.track.id })) : { track: i.track }; var o = new Event("track"); o.track = i.track, o.receiver = n, o.transceiver = { receiver: n }, o.streams = [t.stream], r.dispatchEvent(o) })), t.stream.getTracks().forEach((function (i) { var n; n = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find((function (e) { return e.track && e.track.id === i.id })) : { track: i }; var o = new Event("track"); o.track = i, o.receiver = n, o.transceiver = { receiver: n }, o.streams = [t.stream], r.dispatchEvent(o) })) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else a.wrapPeerConnectionEvent(e, "track", (function (e) { return e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e })) }, r.shimGetSendersWithDtmf = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { var t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; var r = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, i) { var n = r.apply(this, arguments); return n || (n = t(this, e), this._senders.push(n)), n }; var n = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { n.apply(this, arguments); var t = this._senders.indexOf(e); -1 !== t && this._senders.splice(t, 1) } } var o = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var r = this; this._senders = this._senders || [], o.apply(this, [e]), e.getTracks().forEach((function (e) { r._senders.push(t(r, e)) })) }; var a = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._senders = this._senders || [], a.apply(this, [e]), e.getTracks().forEach((function (e) { var r = t._senders.find((function (t) { return t.track === e })); r && t._senders.splice(t._senders.indexOf(r), 1) })) } } else if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { var s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { var e = this, t = s.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get: function () { return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } }, r.shimGetStats = function (e) { if (e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { var e = this, r = Array.prototype.slice.call(arguments), i = r[0], n = r[1], o = r[2]; if (arguments.length > 0 && "function" == typeof i) return t.apply(this, arguments); if (0 === t.length && (0 === arguments.length || "function" != typeof i)) return t.apply(this, []); var a = function (e) { var t = {}; return e.result().forEach((function (e) { var r = { id: e.id, timestamp: e.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type }; e.names().forEach((function (t) { r[t] = e.stat(t) })), t[r.id] = r })), t }, s = function (e) { return new Map(Object.keys(e).map((function (t) { return [t, e[t]] }))) }; if (arguments.length >= 2) { return t.apply(this, [function (e) { n(s(a(e))) }, i]) } return new Promise((function (r, i) { t.apply(e, [function (e) { r(s(a(e))) }, i]) })).then(n, o) } } }, r.shimSenderReceiverGetStats = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver) { if (!("getStats" in e.RTCRtpSender.prototype)) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this, r = t.apply(this, []); return r.forEach((function (t) { return t._pc = e })), r }); var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { var e = r.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { var e = this; return this._pc.getStats().then((function (t) { return a.filterStats(t, e.track, !0) })) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { var n = e.RTCPeerConnection.prototype.getReceivers; n && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, t = n.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }), a.wrapPeerConnectionEvent(e, "track", (function (e) { return e.receiver._pc = e.srcElement, e })), e.RTCRtpReceiver.prototype.getStats = function () { var e = this; return this._pc.getStats().then((function (t) { return a.filterStats(t, e.track, !1) })) } } if ("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype) { var o = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { var t = arguments[0], r = void 0, i = void 0, n = void 0; return this.getSenders().forEach((function (e) { e.track === t && (r ? n = !0 : r = e) })), this.getReceivers().forEach((function (e) { return e.track === t && (i ? n = !0 : i = e), e.track === t })), n || r && i ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : r ? r.getStats() : i ? i.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return o.apply(this, arguments) } } } }, r.shimAddTrackRemoveTrackWithNative = c, r.shimAddTrackRemoveTrack = function (e, t) { if (e.RTCPeerConnection) { if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return c(e); var r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this, t = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, t.map((function (t) { return e._reverseStreams[t.id] })) }; var i = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { var r = this; if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((function (e) { if (r.getSenders().find((function (t) { return t.track === e }))) throw new DOMException("Track already exists.", "InvalidAccessError") })), !this._reverseStreams[t.id]) { var n = new e.MediaStream(t.getTracks()); this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n } i.apply(this, [t]) }; var n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, r) { var i = this; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); var n = [].slice.call(arguments, 1); if (1 !== n.length || !n[0].getTracks().find((function (e) { return e === t }))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find((function (e) { return e.track === t }))) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; var o = this._streams[r.id]; if (o) o.addTrack(t), Promise.resolve().then((function () { i.dispatchEvent(new Event("negotiationneeded")) })); else { var a = new e.MediaStream([t]); this._streams[r.id] = a, this._reverseStreams[a.id] = r, this.addStream(a) } return this.getSenders().find((function (e) { return e.track === t })) }, ["createOffer", "createAnswer"].forEach((function (t) { var r = e.RTCPeerConnection.prototype[t], i = s({}, t, (function () { var e = this, t = arguments; return arguments.length && "function" == typeof arguments[0] ? r.apply(this, [function (r) { var i = l(e, r); t[0].apply(null, [i]) }, function (e) { t[1] && t[1].apply(null, e) }, arguments[2]]) : r.apply(this, arguments).then((function (t) { return l(e, t) })) })); e.RTCPeerConnection.prototype[t] = i[t] })); var o = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = (e = this, r = (t = arguments[0]).sdp, Object.keys(e._reverseStreams || []).forEach((function (t) { var i = e._reverseStreams[t], n = e._streams[i.id]; r = r.replace(new RegExp(i.id, "g"), n.id) })), new RTCSessionDescription({ type: t.type, sdp: r })), o.apply(this, arguments)) : o.apply(this, arguments); var e, t, r }; var a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get: function () { var e = a.get.apply(this); return "" === e.type ? e : l(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; var r = void 0; Object.keys(this._streams).forEach((function (i) { t._streams[i].getTracks().find((function (t) { return e.track === t })) && (r = t._streams[i]) })), r && (1 === r.getTracks().length ? this.removeStream(this._reverseStreams[r.id]) : r.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function l(e, t) { var r = t.sdp; return Object.keys(e._reverseStreams || []).forEach((function (t) { var i = e._reverseStreams[t], n = e._streams[i.id]; r = r.replace(new RegExp(n.id, "g"), i.id) })), new RTCSessionDescription({ type: t.type, sdp: r }) } }, r.shimPeerConnection = function (e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { var r = e.RTCPeerConnection.prototype[t], i = s({}, t, (function () { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments) })); e.RTCPeerConnection.prototype[t] = i[t] })) }, r.fixNegotiationNeeded = function (e, t) { a.wrapPeerConnectionEvent(e, "negotiationneeded", (function (e) { var r = e.target; if (!(t.version < 72 || r.getConfiguration && "plan-b" === r.getConfiguration().sdpSemantics) || "stable" === r.signalingState) return e })) }; var a = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("../utils.js")); function s(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function c(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((function (t) { return e._shimmedLocalStreams[t][0] })) }; var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { if (!r) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; var i = t.apply(this, arguments); return this._shimmedLocalStreams[r.id] ? -1 === this._shimmedLocalStreams[r.id].indexOf(i) && this._shimmedLocalStreams[r.id].push(i) : this._shimmedLocalStreams[r.id] = [r, i], i }; var r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var t = this; this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((function (e) { if (t.getSenders().find((function (t) { return t.track === e }))) throw new DOMException("Track already exists.", "InvalidAccessError") })); var i = this.getSenders(); r.apply(this, arguments); var n = this.getSenders().filter((function (e) { return -1 === i.indexOf(e) })); this._shimmedLocalStreams[e.id] = [e].concat(n) }; var i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments) }; var n = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((function (r) { var i = t._shimmedLocalStreams[r].indexOf(e); -1 !== i && t._shimmedLocalStreams[r].splice(i, 1), 1 === t._shimmedLocalStreams[r].length && delete t._shimmedLocalStreams[r] })), n.apply(this, arguments) } } }, { "../utils.js": 11, "./getdisplaymedia": 4, "./getusermedia": 5 }], 4: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetDisplayMedia = function (e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (r) { return t(r).then((function (t) { var i = r.video && r.video.width, n = r.video && r.video.height, o = r.video && r.video.frameRate; return r.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t, maxFrameRate: o || 3 } }, i && (r.video.mandatory.maxWidth = i), n && (r.video.mandatory.maxHeight = n), e.navigator.mediaDevices.getUserMedia(r) })) } : console.error("shimGetDisplayMedia: getSourceId argument is not a function")) } }, {}], 5: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; r.shimGetUserMedia = function (e, t) { var r = e && e.navigator; if (r.mediaDevices) { var o = function (e) { if ("object" !== (void 0 === e ? "undefined" : i(e)) || e.mandatory || e.optional) return e; var t = {}; return Object.keys(e).forEach((function (r) { if ("require" !== r && "advanced" !== r && "mediaSource" !== r) { var n = "object" === i(e[r]) ? e[r] : { ideal: e[r] }; void 0 !== n.exact && "number" == typeof n.exact && (n.min = n.max = n.exact); var o = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t }; if (void 0 !== n.ideal) { t.optional = t.optional || []; var a = {}; "number" == typeof n.ideal ? (a[o("min", r)] = n.ideal, t.optional.push(a), (a = {})[o("max", r)] = n.ideal, t.optional.push(a)) : (a[o("", r)] = n.ideal, t.optional.push(a)) } void 0 !== n.exact && "number" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[o("", r)] = n.exact) : ["min", "max"].forEach((function (e) { void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[o(e, r)] = n[e]) })) } })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, a = function (e, a) { if (t.version >= 61) return a(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" === i(e.audio)) { var s = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }; s((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), s(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = o(e.audio) } if (e && "object" === i(e.video)) { var c = e.video.facingMode; c = c && ("object" === (void 0 === c ? "undefined" : i(c)) ? c : { ideal: c }); var l = t.version < 66; if (c && ("user" === c.exact || "environment" === c.exact || "user" === c.ideal || "environment" === c.ideal) && (!r.mediaDevices.getSupportedConstraints || !r.mediaDevices.getSupportedConstraints().facingMode || l)) { delete e.video.facingMode; var d = void 0; if ("environment" === c.exact || "environment" === c.ideal ? d = ["back", "rear"] : "user" !== c.exact && "user" !== c.ideal || (d = ["front"]), d) return r.mediaDevices.enumerateDevices().then((function (t) { var r = (t = t.filter((function (e) { return "videoinput" === e.kind }))).find((function (e) { return d.some((function (t) { return e.label.toLowerCase().includes(t) })) })); return !r && t.length && d.includes("back") && (r = t[t.length - 1]), r && (e.video.deviceId = c.exact ? { exact: r.deviceId } : { ideal: r.deviceId }), e.video = o(e.video), n("chrome: " + JSON.stringify(e)), a(e) })) } e.video = o(e.video) } return n("chrome: " + JSON.stringify(e)), a(e) }, s = function (e) { return t.version >= 64 ? e : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString: function () { return this.name + (this.message && ": ") + this.message } } }; if (r.getUserMedia = function (e, t, i) { a(e, (function (e) { r.webkitGetUserMedia(e, t, (function (e) { i && i(s(e)) })) })) }.bind(r), r.mediaDevices.getUserMedia) { var c = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (e) { return a(e, (function (e) { return c(e).then((function (t) { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach((function (e) { e.stop() })), new DOMException("", "NotFoundError"); return t }), (function (e) { return Promise.reject(s(e)) })) })) } } } }; var n = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("../utils.js")).log }, { "../utils.js": 11 }], 6: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; r.shimRTCIceCandidate = function (e) { if (!(!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype)) { var t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { var r = new t(e), n = o.default.parseCandidate(e.candidate), a = Object.assign(r, n); return a.toJSON = function () { return { candidate: a.candidate, sdpMid: a.sdpMid, sdpMLineIndex: a.sdpMLineIndex, usernameFragment: a.usernameFragment } }, a } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, a.wrapPeerConnectionEvent(e, "icecandidate", (function (t) { return t.candidate && Object.defineProperty(t, "candidate", { value: new e.RTCIceCandidate(t.candidate), writable: "false" }), t })) } }, r.shimMaxMessageSize = function (e, t) { if (e.RTCPeerConnection) { "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get: function () { return void 0 === this._sctp ? null : this._sctp } }); var r = function (e) { if (!e || !e.sdp) return !1; var t = o.default.splitSections(e.sdp); return t.shift(), t.some((function (e) { var t = o.default.parseMLine(e); return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP") })) }, i = function (e) { var t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (null === t || t.length < 2) return -1; var r = parseInt(t[1], 10); return r != r ? -1 : r }, n = function (e) { var r = 65536; return "firefox" === t.browser && (r = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), r }, a = function (e, r) { var i = 65536; "firefox" === t.browser && 57 === t.version && (i = 65535); var n = o.default.matchPrefix(e.sdp, "a=max-message-size:"); return n.length > 0 ? i = parseInt(n[0].substr(19), 10) : "firefox" === t.browser && -1 !== r && (i = 2147483637), i }, s = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, "chrome" === t.browser && t.version >= 76 && "plan-b" === this.getConfiguration().sdpSemantics && Object.defineProperty(this, "sctp", { get: function () { return void 0 === this._sctp ? null : this._sctp }, enumerable: !0, configurable: !0 }), r(arguments[0])) { var e, o = i(arguments[0]), c = n(o), l = a(arguments[0], o); e = 0 === c && 0 === l ? Number.POSITIVE_INFINITY : 0 === c || 0 === l ? Math.max(c, l) : Math.min(c, l); var d = {}; Object.defineProperty(d, "maxMessageSize", { get: function () { return e } }), this._sctp = d } return s.apply(this, arguments) } } }, r.shimSendThrowTypeError = function (e) { if (e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype) { var t = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { var e = t.apply(this, arguments); return r(e, this), e }, a.wrapPeerConnectionEvent(e, "datachannel", (function (e) { return r(e.channel, e.target), e })) } function r(e, t) { var r = e.send; e.send = function () { var i = arguments[0], n = i.length || i.size || i.byteLength; if ("open" === e.readyState && t.sctp && n > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)"); return r.apply(e, arguments) } } }, r.shimConnectionState = function (e) { if (e.RTCPeerConnection && !("connectionState" in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get: function () { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get: function () { return this._onconnectionstatechange || null }, set: function (e) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach((function (e) { var r = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = function (e) { var t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; var r = new Event("connectionstatechange", e); t.dispatchEvent(r) } return e }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), r.apply(this, arguments) } })) } }, r.removeExtmapAllowMixed = function (e, t) { if (e.RTCPeerConnection && !("chrome" === t.browser && t.version >= 71 || "safari" === t.browser && t.version >= 605)) { var r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) { if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) { var i = t.sdp.split("\n").filter((function (e) { return "a=extmap-allow-mixed" !== e.trim() })).join("\n"); e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: i }) : t.sdp = i } return r.apply(this, arguments) } } }, r.shimAddIceCandidateNullOrEmpty = function (e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { var r = e.RTCPeerConnection.prototype.addIceCandidate; r && 0 !== r.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } }; var n, o = (n = e("sdp")) && n.__esModule ? n : { default: n }, a = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("./utils")) }, { "./utils": 11, sdp: 12 }], 7: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = e("./getusermedia"); Object.defineProperty(r, "shimGetUserMedia", { enumerable: !0, get: function () { return n.shimGetUserMedia } }); var o = e("./getdisplaymedia"); Object.defineProperty(r, "shimGetDisplayMedia", { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimOnTrack = function (e) { "object" === (void 0 === e ? "undefined" : i(e)) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: function () { return { receiver: this.receiver } } }) }, r.shimPeerConnection = function (e, t) { if ("object" === (void 0 === e ? "undefined" : i(e)) && (e.RTCPeerConnection || e.mozRTCPeerConnection)) { !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { var r, i, n, o = e.RTCPeerConnection.prototype[t], a = (n = function () { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), o.apply(this, arguments) }, (i = t) in (r = {}) ? Object.defineProperty(r, i, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : r[i] = n, r); e.RTCPeerConnection.prototype[t] = a[t] })); var r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { var e = Array.prototype.slice.call(arguments), i = e[0], o = e[1], a = e[2]; return n.apply(this, [i || null]).then((function (e) { if (t.version < 53 && !o) try { e.forEach((function (e) { e.type = r[e.type] || e.type })) } catch (t) { if ("TypeError" !== t.name) throw t; e.forEach((function (t, i) { e.set(i, Object.assign({}, t, { type: r[t.type] || t.type })) })) } return e })).then(o, a) } } }, r.shimSenderGetStats = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpSender.prototype))) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this, r = t.apply(this, []); return r.forEach((function (t) { return t._pc = e })), r }); var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { var e = r.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } }, r.shimReceiverGetStats = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpReceiver.prototype))) { var t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, r = t.apply(this, []); return r.forEach((function (t) { return t._pc = e })), r }), a.wrapPeerConnectionEvent(e, "track", (function (e) { return e.receiver._pc = e.srcElement, e })), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } }, r.shimRemoveStream = function (e) { e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; a.deprecated("removeStream", "removeTrack"), this.getSenders().forEach((function (r) { r.track && e.getTracks().includes(r.track) && t.removeTrack(r) })) }) }, r.shimRTCDataChannel = function (e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) }, r.shimAddTransceiver = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; var e = arguments[1], r = e && "sendEncodings" in e; r && e.sendEncodings.forEach((function (e) { if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") })); var i = t.apply(this, arguments); if (r) { var n = i.sender, o = n.getParameters(); (!("encodings" in o) || 1 === o.encodings.length && 0 === Object.keys(o.encodings[0]).length) && (o.encodings = e.sendEncodings, n.sendEncodings = e.sendEncodings, this.setParametersPromises.push(n.setParameters(o).then((function () { delete n.sendEncodings })).catch((function () { delete n.sendEncodings })))) } return i }) } }, r.shimGetParameters = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCRtpSender) { var t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { var e = t.apply(this, arguments); return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e }) } }, r.shimCreateOffer = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { var e = this, r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((function () { return t.apply(e, r) })).finally((function () { e.setParametersPromises = [] })) : t.apply(this, arguments) } } }, r.shimCreateAnswer = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { var e = this, r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((function () { return t.apply(e, r) })).finally((function () { e.setParametersPromises = [] })) : t.apply(this, arguments) } } }; var a = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("../utils")) }, { "../utils": 11, "./getdisplaymedia": 8, "./getusermedia": 9 }], 8: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetDisplayMedia = function (e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (r) { if (!r || !r.video) { var i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return !0 === r.video ? r.video = { mediaSource: t } : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r) }) } }, {}], 9: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; r.shimGetUserMedia = function (e, t) { var r = e && e.navigator, o = e && e.MediaStreamTrack; if (r.getUserMedia = function (e, t, i) { n.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(e).then(t, i) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { var a = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }, s = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (e) { return "object" === (void 0 === e ? "undefined" : i(e)) && "object" === i(e.audio) && (e = JSON.parse(JSON.stringify(e)), a(e.audio, "autoGainControl", "mozAutoGainControl"), a(e.audio, "noiseSuppression", "mozNoiseSuppression")), s(e) }, o && o.prototype.getSettings) { var c = o.prototype.getSettings; o.prototype.getSettings = function () { var e = c.apply(this, arguments); return a(e, "mozAutoGainControl", "autoGainControl"), a(e, "mozNoiseSuppression", "noiseSuppression"), e } } if (o && o.prototype.applyConstraints) { var l = o.prototype.applyConstraints; o.prototype.applyConstraints = function (e) { return "audio" === this.kind && "object" === (void 0 === e ? "undefined" : i(e)) && (e = JSON.parse(JSON.stringify(e)), a(e, "autoGainControl", "mozAutoGainControl"), a(e, "noiseSuppression", "mozNoiseSuppression")), l.apply(this, [e]) } } } }; var n = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("../utils")) }, { "../utils": 11 }], 10: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; r.shimLocalStreamsAPI = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { var r = this; this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((function (i) { return t.call(r, i, e) })), e.getVideoTracks().forEach((function (i) { return t.call(r, i, e) })) }, e.RTCPeerConnection.prototype.addTrack = function (e) { for (var r = this, i = arguments.length, n = Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)n[o - 1] = arguments[o]; return n && n.forEach((function (e) { r._localStreams ? r._localStreams.includes(e) || r._localStreams.push(e) : r._localStreams = [e] })), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._localStreams || (this._localStreams = []); var r = this._localStreams.indexOf(e); if (-1 !== r) { this._localStreams.splice(r, 1); var i = e.getTracks(); this.getSenders().forEach((function (e) { i.includes(e.track) && t.removeTrack(e) })) } }) } }, r.shimRemoteStreamsAPI = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get: function () { return this._onaddstream }, set: function (e) { var t = this; this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = function (e) { e.streams.forEach((function (e) { if (t._remoteStreams || (t._remoteStreams = []), !t._remoteStreams.includes(e)) { t._remoteStreams.push(e); var r = new Event("addstream"); r.stream = e, t.dispatchEvent(r) } })) }) } }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var e = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) { t.streams.forEach((function (t) { if (e._remoteStreams || (e._remoteStreams = []), !(e._remoteStreams.indexOf(t) >= 0)) { e._remoteStreams.push(t); var r = new Event("addstream"); r.stream = t, e.dispatchEvent(r) } })) }), t.apply(e, arguments) } } }, r.shimCallbacksAPI = function (e) { if ("object" === (void 0 === e ? "undefined" : i(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, o = t.setLocalDescription, a = t.setRemoteDescription, s = t.addIceCandidate; t.createOffer = function (e, t) { var i = arguments.length >= 2 ? arguments[2] : arguments[0], n = r.apply(this, [i]); return t ? (n.then(e, t), Promise.resolve()) : n }, t.createAnswer = function (e, t) { var r = arguments.length >= 2 ? arguments[2] : arguments[0], i = n.apply(this, [r]); return t ? (i.then(e, t), Promise.resolve()) : i }; var c = function (e, t, r) { var i = o.apply(this, [e]); return r ? (i.then(t, r), Promise.resolve()) : i }; t.setLocalDescription = c, c = function (e, t, r) { var i = a.apply(this, [e]); return r ? (i.then(t, r), Promise.resolve()) : i }, t.setRemoteDescription = c, c = function (e, t, r) { var i = s.apply(this, [e]); return r ? (i.then(t, r), Promise.resolve()) : i }, t.addIceCandidate = c } }, r.shimGetUserMedia = function (e) { var t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { var r = t.mediaDevices, i = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = function (e) { return i(o(e)) } } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, r, i) { t.mediaDevices.getUserMedia(e).then(r, i) }.bind(t)) }, r.shimConstraints = o, r.shimRTCIceServerUrls = function (e) { if (e.RTCPeerConnection) { var t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, r) { if (e && e.iceServers) { for (var i = [], o = 0; o < e.iceServers.length; o++) { var a = e.iceServers[o]; !a.hasOwnProperty("urls") && a.hasOwnProperty("url") ? (n.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (a = JSON.parse(JSON.stringify(a))).urls = a.url, delete a.url, i.push(a)) : i.push(e.iceServers[o]) } e.iceServers = i } return new t(e, r) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: function () { return t.generateCertificate } }) } }, r.shimTrackEventTransceiver = function (e) { "object" === (void 0 === e ? "undefined" : i(e)) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: function () { return { receiver: this.receiver } } }) }, r.shimCreateOfferLegacy = function (e) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); var r = this.getTransceivers().find((function (e) { return "audio" === e.receiver.track.kind })); !1 === e.offerToReceiveAudio && r ? "sendrecv" === r.direction ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : "recvonly" === r.direction && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : !0 !== e.offerToReceiveAudio || r || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); var i = this.getTransceivers().find((function (e) { return "video" === e.receiver.track.kind })); !1 === e.offerToReceiveVideo && i ? "sendrecv" === i.direction ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : "recvonly" === i.direction && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : !0 !== e.offerToReceiveVideo || i || this.addTransceiver("video") } return t.apply(this, arguments) } }, r.shimAudioContext = function (e) { "object" !== (void 0 === e ? "undefined" : i(e)) || e.AudioContext || (e.AudioContext = e.webkitAudioContext) }; var n = function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t }(e("../utils")); function o(e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: n.compactObject(e.video) }) : e } }, { "../utils": 11 }], 11: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; r.extractVersion = a, r.wrapPeerConnectionEvent = function (e, t, r) { if (e.RTCPeerConnection) { var i = e.RTCPeerConnection.prototype, n = i.addEventListener; i.addEventListener = function (e, i) { if (e !== t) return n.apply(this, arguments); var o = function (e) { var t = r(e); t && (i.handleEvent ? i.handleEvent(t) : i(t)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, o), n.apply(this, [e, o]) }; var o = i.removeEventListener; i.removeEventListener = function (e, r) { if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments); if (!this._eventMap[t].has(r)) return o.apply(this, arguments); var i = this._eventMap[t].get(r); return this._eventMap[t].delete(r), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, i]) }, Object.defineProperty(i, "on" + t, { get: function () { return this["_on" + t] }, set: function (e) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e) }, enumerable: !0, configurable: !0 }) } }, r.disableLog = function (e) { return "boolean" != typeof e ? new Error("Argument type: " + (void 0 === e ? "undefined" : i(e)) + ". Please use a boolean.") : (n = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") }, r.disableWarnings = function (e) { return "boolean" != typeof e ? new Error("Argument type: " + (void 0 === e ? "undefined" : i(e)) + ". Please use a boolean.") : (o = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) }, r.log = function () { if ("object" === ("undefined" == typeof window ? "undefined" : i(window))) { if (n) return; "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments) } }, r.deprecated = function (e, t) { o && console.warn(e + " is deprecated, please use " + t + " instead.") }, r.detectBrowser = function (e) { var t = { browser: null, version: null }; if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t; var r = e.navigator; if (r.mozGetUserMedia) t.browser = "firefox", t.version = a(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = a(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!e.RTCPeerConnection || !r.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t; t.browser = "safari", t.version = a(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype } return t }, r.compactObject = function e(t) { return s(t) ? Object.keys(t).reduce((function (r, i) { var n = s(t[i]), o = n ? e(t[i]) : t[i], a = n && !Object.keys(o).length; return void 0 === o || a ? r : Object.assign(r, function (e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e }({}, i, o)) }), {}) : t }, r.walkStats = c, r.filterStats = function (e, t, r) { var i = r ? "outbound-rtp" : "inbound-rtp", n = new Map; if (null === t) return n; var o = []; return e.forEach((function (e) { "track" === e.type && e.trackIdentifier === t.id && o.push(e) })), o.forEach((function (t) { e.forEach((function (r) { r.type === i && r.trackId === t.id && c(e, r, n) })) })), n }; var n = !0, o = !0; function a(e, t, r) { var i = e.match(t); return i && i.length >= r && parseInt(i[r], 10) } function s(e) { return "[object Object]" === Object.prototype.toString.call(e) } function c(e, t, r) { t && !r.has(t.id) && (r.set(t.id, t), Object.keys(t).forEach((function (i) { i.endsWith("Id") ? c(e, e.get(t[i]), r) : i.endsWith("Ids") && t[i].forEach((function (t) { c(e, e.get(t), r) })) }))) } }, {}], 12: [function (e, t, r) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = { generateIdentifier: function () { return Math.random().toString(36).substr(2, 10) } }; n.localCName = n.generateIdentifier(), n.splitLines = function (e) { return e.trim().split("\n").map((function (e) { return e.trim() })) }, n.splitSections = function (e) { return e.split("\nm=").map((function (e, t) { return (t > 0 ? "m=" + e : e).trim() + "\r\n" })) }, n.getDescription = function (e) { var t = n.splitSections(e); return t && t[0] }, n.getMediaSections = function (e) { var t = n.splitSections(e); return t.shift(), t }, n.matchPrefix = function (e, t) { return n.splitLines(e).filter((function (e) { return 0 === e.indexOf(t) })) }, n.parseCandidate = function (e) { for (var t = void 0, r = { foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0], component: { 1: "rtp", 2: "rtcp" }[t[1]], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, i = 8; i < t.length; i += 2)switch (t[i]) { case "raddr": r.relatedAddress = t[i + 1]; break; case "rport": r.relatedPort = parseInt(t[i + 1], 10); break; case "tcptype": r.tcpType = t[i + 1]; break; case "ufrag": r.ufrag = t[i + 1], r.usernameFragment = t[i + 1]; break; default: void 0 === r[t[i]] && (r[t[i]] = t[i + 1]) }return r }, n.writeCandidate = function (e) { var t = []; t.push(e.foundation); var r = e.component; "rtp" === r ? t.push(1) : "rtcp" === r ? t.push(2) : t.push(r), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); var i = e.type; return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ") }, n.parseIceOptions = function (e) { return e.substr(14).split(" ") }, n.parseRtpMap = function (e) { var t = e.substr(9).split(" "), r = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split("/"), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = 3 === t.length ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r }, n.writeRtpMap = function (e) { var t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); var r = e.channels || e.numChannels || 1; return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== r ? "/" + r : "") + "\r\n" }, n.parseExtmap = function (e) { var t = e.substr(9).split(" "); return { id: parseInt(t[0], 10), direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv", uri: t[1] } }, n.writeExtmap = function (e) { return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n" }, n.parseFmtp = function (e) { for (var t = {}, r = void 0, i = e.substr(e.indexOf(" ") + 1).split(";"), n = 0; n < i.length; n++)t[(r = i[n].trim().split("="))[0].trim()] = r[1]; return t }, n.writeFmtp = function (e) { var t = "", r = e.payloadType; if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { var i = []; Object.keys(e.parameters).forEach((function (t) { e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t) })), t += "a=fmtp:" + r + " " + i.join(";") + "\r\n" } return t }, n.parseRtcpFb = function (e) { var t = e.substr(e.indexOf(" ") + 1).split(" "); return { type: t.shift(), parameter: t.join(" ") } }, n.writeRtcpFb = function (e) { var t = "", r = e.payloadType; return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((function (e) { t += "a=rtcp-fb:" + r + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n" })), t }, n.parseSsrcMedia = function (e) { var t = e.indexOf(" "), r = { ssrc: parseInt(e.substr(7, t - 7), 10) }, i = e.indexOf(":", t); return i > -1 ? (r.attribute = e.substr(t + 1, i - t - 1), r.value = e.substr(i + 1)) : r.attribute = e.substr(t + 1), r }, n.parseSsrcGroup = function (e) { var t = e.substr(13).split(" "); return { semantics: t.shift(), ssrcs: t.map((function (e) { return parseInt(e, 10) })) } }, n.getMid = function (e) { var t = n.matchPrefix(e, "a=mid:")[0]; if (t) return t.substr(6) }, n.parseFingerprint = function (e) { var t = e.substr(14).split(" "); return { algorithm: t[0].toLowerCase(), value: t[1] } }, n.getDtlsParameters = function (e, t) { return { role: "auto", fingerprints: n.matchPrefix(e + t, "a=fingerprint:").map(n.parseFingerprint) } }, n.writeDtlsParameters = function (e, t) { var r = "a=setup:" + t + "\r\n"; return e.fingerprints.forEach((function (e) { r += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n" })), r }, n.parseCryptoLine = function (e) { var t = e.substr(9).split(" "); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) } }, n.writeCryptoLine = function (e) { return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" === i(e.keyParams) ? n.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n" }, n.parseCryptoKeyParams = function (e) { if (0 !== e.indexOf("inline:")) return null; var t = e.substr(7).split("|"); return { keyMethod: "inline", keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(":")[0] : void 0, mkiLength: t[2] ? t[2].split(":")[1] : void 0 } }, n.writeCryptoKeyParams = function (e) { return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "") }, n.getCryptoParameters = function (e, t) { return n.matchPrefix(e + t, "a=crypto:").map(n.parseCryptoLine) }, n.getIceParameters = function (e, t) { var r = n.matchPrefix(e + t, "a=ice-ufrag:")[0], i = n.matchPrefix(e + t, "a=ice-pwd:")[0]; return r && i ? { usernameFragment: r.substr(12), password: i.substr(10) } : null }, n.writeIceParameters = function (e) { var t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"; return e.iceLite && (t += "a=ice-lite\r\n"), t }, n.parseRtpParameters = function (e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = n.splitLines(e)[0].split(" "), i = 3; i < r.length; i++) { var o = r[i], a = n.matchPrefix(e, "a=rtpmap:" + o + " ")[0]; if (a) { var s = n.parseRtpMap(a), c = n.matchPrefix(e, "a=fmtp:" + o + " "); switch (s.parameters = c.length ? n.parseFmtp(c[0]) : {}, s.rtcpFeedback = n.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(n.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) { case "RED": case "ULPFEC": t.fecMechanisms.push(s.name.toUpperCase()) } } } return n.matchPrefix(e, "a=extmap:").forEach((function (e) { t.headerExtensions.push(n.parseExtmap(e)) })), t }, n.writeRtpDescription = function (e, t) { var r = ""; r += "m=" + e + " ", r += t.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += t.codecs.map((function (e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType })).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((function (e) { r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e) })); var i = 0; return t.codecs.forEach((function (e) { e.maxptime > i && (i = e.maxptime) })), i > 0 && (r += "a=maxptime:" + i + "\r\n"), t.headerExtensions && t.headerExtensions.forEach((function (e) { r += n.writeExtmap(e) })), r }, n.parseRtpEncodingParameters = function (e) { var t = [], r = n.parseRtpParameters(e), i = -1 !== r.fecMechanisms.indexOf("RED"), o = -1 !== r.fecMechanisms.indexOf("ULPFEC"), a = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "cname" === e.attribute })), s = a.length > 0 && a[0].ssrc, c = void 0, l = n.matchPrefix(e, "a=ssrc-group:FID").map((function (e) { return e.substr(17).split(" ").map((function (e) { return parseInt(e, 10) })) })); l.length > 0 && l[0].length > 1 && l[0][0] === s && (c = l[0][1]), r.codecs.forEach((function (e) { if ("RTX" === e.name.toUpperCase() && e.parameters.apt) { var r = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10) }; s && c && (r.rtx = { ssrc: c }), t.push(r), i && ((r = JSON.parse(JSON.stringify(r))).fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, t.push(r)) } })), 0 === t.length && s && t.push({ ssrc: s }); var d = n.matchPrefix(e, "b="); return d.length && (d = 0 === d[0].indexOf("b=TIAS:") ? parseInt(d[0].substr(7), 10) : 0 === d[0].indexOf("b=AS:") ? 1e3 * parseInt(d[0].substr(5), 10) * .95 - 16e3 : void 0, t.forEach((function (e) { e.maxBitrate = d }))), t }, n.parseRtcpParameters = function (e) { var t = {}, r = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "cname" === e.attribute }))[0]; r && (t.cname = r.value, t.ssrc = r.ssrc); var i = n.matchPrefix(e, "a=rtcp-rsize"); t.reducedSize = i.length > 0, t.compound = 0 === i.length; var o = n.matchPrefix(e, "a=rtcp-mux"); return t.mux = o.length > 0, t }, n.writeRtcpParameters = function (e) { var t = ""; return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t }, n.parseMsid = function (e) { var t = void 0, r = n.matchPrefix(e, "a=msid:"); if (1 === r.length) return { stream: (t = r[0].substr(7).split(" "))[0], track: t[1] }; var i = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "msid" === e.attribute })); return i.length > 0 ? { stream: (t = i[0].value.split(" "))[0], track: t[1] } : void 0 }, n.parseSctpDescription = function (e) { var t = n.parseMLine(e), r = n.matchPrefix(e, "a=max-message-size:"), i = void 0; r.length > 0 && (i = parseInt(r[0].substr(19), 10)), isNaN(i) && (i = 65536); var o = n.matchPrefix(e, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: t.fmt, maxMessageSize: i }; var a = n.matchPrefix(e, "a=sctpmap:"); if (a.length > 0) { var s = a[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: i } } }, n.writeSctpDescription = function (e, t) { var r = []; return r = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && r.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), r.join("") }, n.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, n.writeSessionBoilerplate = function (e, t, r) { var i = void 0 !== t ? t : 2; return "v=0\r\no=" + (r || "thisisadapterortc") + " " + (e || n.generateSessionId()) + " " + i + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n" }, n.getDirection = function (e, t) { for (var r = n.splitLines(e), i = 0; i < r.length; i++)switch (r[i]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return r[i].substr(2) }return t ? n.getDirection(t) : "sendrecv" }, n.getKind = function (e) { return n.splitLines(e)[0].split(" ")[0].substr(2) }, n.isRejected = function (e) { return "0" === e.split(" ", 2)[1] }, n.parseMLine = function (e) { var t = n.splitLines(e)[0].substr(2).split(" "); return { kind: t[0], port: parseInt(t[1], 10), protocol: t[2], fmt: t.slice(3).join(" ") } }, n.parseOLine = function (e) { var t = n.matchPrefix(e, "o=")[0].substr(2).split(" "); return { username: t[0], sessionId: t[1], sessionVersion: parseInt(t[2], 10), netType: t[3], addressType: t[4], address: t[5] } }, n.isValidSDP = function (e) { if ("string" != typeof e || 0 === e.length) return !1; for (var t = n.splitLines(e), r = 0; r < t.length; r++)if (t[r].length < 2 || "=" !== t[r].charAt(1)) return !1; return !0 }, "object" === (void 0 === t ? "undefined" : i(t)) && (t.exports = n) }, {}] }, {}, [1])(1) }, 375: function (e, t, r) { var i; !function (n) { "use strict"; function o(e, t) { var r = (65535 & e) + (65535 & t); return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r } function a(e, t, r, i, n, a) { return o((s = o(o(t, e), o(i, a))) << (c = n) | s >>> 32 - c, r); var s, c } function s(e, t, r, i, n, o, s) { return a(t & r | ~t & i, e, t, n, o, s) } function c(e, t, r, i, n, o, s) { return a(t & i | r & ~i, e, t, n, o, s) } function l(e, t, r, i, n, o, s) { return a(t ^ r ^ i, e, t, n, o, s) } function d(e, t, r, i, n, o, s) { return a(r ^ (t | ~i), e, t, n, o, s) } function u(e, t) { var r, i, n, a, u; e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t; var p = 1732584193, g = -271733879, f = -1732584194, h = 271733878; for (r = 0; r < e.length; r += 16)i = p, n = g, a = f, u = h, p = s(p, g, f, h, e[r], 7, -680876936), h = s(h, p, g, f, e[r + 1], 12, -389564586), f = s(f, h, p, g, e[r + 2], 17, 606105819), g = s(g, f, h, p, e[r + 3], 22, -1044525330), p = s(p, g, f, h, e[r + 4], 7, -176418897), h = s(h, p, g, f, e[r + 5], 12, 1200080426), f = s(f, h, p, g, e[r + 6], 17, -1473231341), g = s(g, f, h, p, e[r + 7], 22, -45705983), p = s(p, g, f, h, e[r + 8], 7, 1770035416), h = s(h, p, g, f, e[r + 9], 12, -1958414417), f = s(f, h, p, g, e[r + 10], 17, -42063), g = s(g, f, h, p, e[r + 11], 22, -1990404162), p = s(p, g, f, h, e[r + 12], 7, 1804603682), h = s(h, p, g, f, e[r + 13], 12, -40341101), f = s(f, h, p, g, e[r + 14], 17, -1502002290), p = c(p, g = s(g, f, h, p, e[r + 15], 22, 1236535329), f, h, e[r + 1], 5, -165796510), h = c(h, p, g, f, e[r + 6], 9, -1069501632), f = c(f, h, p, g, e[r + 11], 14, 643717713), g = c(g, f, h, p, e[r], 20, -373897302), p = c(p, g, f, h, e[r + 5], 5, -701558691), h = c(h, p, g, f, e[r + 10], 9, 38016083), f = c(f, h, p, g, e[r + 15], 14, -660478335), g = c(g, f, h, p, e[r + 4], 20, -405537848), p = c(p, g, f, h, e[r + 9], 5, 568446438), h = c(h, p, g, f, e[r + 14], 9, -1019803690), f = c(f, h, p, g, e[r + 3], 14, -187363961), g = c(g, f, h, p, e[r + 8], 20, 1163531501), p = c(p, g, f, h, e[r + 13], 5, -1444681467), h = c(h, p, g, f, e[r + 2], 9, -51403784), f = c(f, h, p, g, e[r + 7], 14, 1735328473), p = l(p, g = c(g, f, h, p, e[r + 12], 20, -1926607734), f, h, e[r + 5], 4, -378558), h = l(h, p, g, f, e[r + 8], 11, -2022574463), f = l(f, h, p, g, e[r + 11], 16, 1839030562), g = l(g, f, h, p, e[r + 14], 23, -35309556), p = l(p, g, f, h, e[r + 1], 4, -1530992060), h = l(h, p, g, f, e[r + 4], 11, 1272893353), f = l(f, h, p, g, e[r + 7], 16, -155497632), g = l(g, f, h, p, e[r + 10], 23, -1094730640), p = l(p, g, f, h, e[r + 13], 4, 681279174), h = l(h, p, g, f, e[r], 11, -358537222), f = l(f, h, p, g, e[r + 3], 16, -722521979), g = l(g, f, h, p, e[r + 6], 23, 76029189), p = l(p, g, f, h, e[r + 9], 4, -640364487), h = l(h, p, g, f, e[r + 12], 11, -421815835), f = l(f, h, p, g, e[r + 15], 16, 530742520), p = d(p, g = l(g, f, h, p, e[r + 2], 23, -995338651), f, h, e[r], 6, -198630844), h = d(h, p, g, f, e[r + 7], 10, 1126891415), f = d(f, h, p, g, e[r + 14], 15, -1416354905), g = d(g, f, h, p, e[r + 5], 21, -57434055), p = d(p, g, f, h, e[r + 12], 6, 1700485571), h = d(h, p, g, f, e[r + 3], 10, -1894986606), f = d(f, h, p, g, e[r + 10], 15, -1051523), g = d(g, f, h, p, e[r + 1], 21, -2054922799), p = d(p, g, f, h, e[r + 8], 6, 1873313359), h = d(h, p, g, f, e[r + 15], 10, -30611744), f = d(f, h, p, g, e[r + 6], 15, -1560198380), g = d(g, f, h, p, e[r + 13], 21, 1309151649), p = d(p, g, f, h, e[r + 4], 6, -145523070), h = d(h, p, g, f, e[r + 11], 10, -1120210379), f = d(f, h, p, g, e[r + 2], 15, 718787259), g = d(g, f, h, p, e[r + 9], 21, -343485551), p = o(p, i), g = o(g, n), f = o(f, a), h = o(h, u); return [p, g, f, h] } function p(e) { var t, r = "", i = 32 * e.length; for (t = 0; t < i; t += 8)r += String.fromCharCode(e[t >> 5] >>> t % 32 & 255); return r } function g(e) { var t, r = []; for (r[(e.length >> 2) - 1] = void 0, t = 0; t < r.length; t += 1)r[t] = 0; var i = 8 * e.length; for (t = 0; t < i; t += 8)r[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32; return r } function f(e) { var t, r, i = "0123456789abcdef", n = ""; for (r = 0; r < e.length; r += 1)t = e.charCodeAt(r), n += i.charAt(t >>> 4 & 15) + i.charAt(15 & t); return n } function h(e) { return unescape(encodeURIComponent(e)) } function m(e) { return function (e) { return p(u(g(e), 8 * e.length)) }(h(e)) } function S(e, t) { return function (e, t) { var r, i, n = g(e), o = [], a = []; for (o[15] = a[15] = void 0, n.length > 16 && (n = u(n, 8 * e.length)), r = 0; r < 16; r += 1)o[r] = 909522486 ^ n[r], a[r] = 1549556828 ^ n[r]; return i = u(o.concat(g(t)), 512 + 8 * t.length), p(u(a.concat(i), 640)) }(h(e), h(t)) } function b(e, t, r) { return t ? r ? S(t, e) : f(S(t, e)) : r ? m(e) : f(m(e)) } void 0 === (i = function () { return b }.call(t, r, t, e)) || (e.exports = i) }() }, 735: (e, t, r) => { var i; (e.exports ? function (t) { e.exports = t() } : r.amdD)((function () { "use strict"; function e(e, t) { return null != e && null != t && e.toLowerCase() === t.toLowerCase() } function t(e, t) { var r, i, n = e.length; if (!n || !t) return !1; for (r = t.toLowerCase(), i = 0; i < n; ++i)if (r === e[i].toLowerCase()) return !0; return !1 } function r(e) { for (var t in e) s.call(e, t) && (e[t] = new RegExp(e[t], "i")) } function n(e, t) { this.ua = function (e) { return (e || "").substr(0, 500) }(e), this._cache = {}, this.maxPhoneWidth = t || 600 } var o, a = { mobileDetectRules: { phones: { iPhone: "\\biPhone\\b|\\biPod\\b", BlackBerry: "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+", Pixel: "; \\bPixel\\b", HTC: "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel", Nexus: "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 5X|Nexus 6", Dell: "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b", Motorola: "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052", Samsung: "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F|SM-G610F|SM-G981B|SM-G892A|SM-A530F", LG: "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710", Sony: "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533|SOV34|601SO|F8332", Asus: "Asus.*Galaxy|PadFone.*Mobile", Xiaomi: "^(?!.*\\bx11\\b).*xiaomi.*$|POCOPHONE F1|MI 8|Redmi Note 9S|Redmi Note 5A Prime|N2G47H|M2001J2G|M2001J2I|M1805E10A|M2004J11G|M1902F1G|M2002J9G|M2004J19G|M2003J6A1G", NokiaLumia: "Lumia [0-9]{3,4}", Micromax: "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b", Palm: "PalmSource|Palm", Vertu: "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature", Pantech: "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790", Fly: "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250", Wiko: "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM", iMobile: "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)", SimValley: "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b", Wolfgang: "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q", Alcatel: "Alcatel", Nintendo: "Nintendo (3DS|Switch)", Amoi: "Amoi", INQ: "INQ", OnePlus: "ONEPLUS", GenericPhone: "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser" }, tablets: { iPad: "iPad|iPad.*Mobile", NexusTablet: "Android.*Nexus[\\s]+(7|9|10)", GoogleTablet: "Android.*Pixel C", SamsungTablet: "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V|SM-P610|SM-T290|SM-T515|SM-T590|SM-T595|SM-T725|SM-T817P|SM-P585N0|SM-T395|SM-T295|SM-T865|SM-P610N|SM-P615|SM-T970|SM-T380|SM-T5950|SM-T905|SM-T231|SM-T500|SM-T860", Kindle: "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome/[0-9.]+ (?!Mobile)", SurfaceTablet: "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)", HPTablet: "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10", AsusTablet: "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b", BlackBerryTablet: "PlayBook|RIM Tablet", HTCtablet: "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410", MotorolaTablet: "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617", NookTablet: "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2", AcerTablet: "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30|A3-A40", ToshibaTablet: "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO", LGTablet: "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b", FujitsuTablet: "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b", PrestigioTablet: "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002", LenovoTablet: "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X|TB-X704F|TB-X104F|TB3-X70F|TB-X705F|TB-8504F|TB3-X70L|TB3-710F|TB-X704L", DellTablet: "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7", YarvikTablet: "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b", MedionTablet: "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB", ArnovaTablet: "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2", IntensoTablet: "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004", IRUTablet: "M702pro", MegafonTablet: "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b", EbodaTablet: "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)", AllViewTablet: "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)", ArchosTablet: "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b", AinolTablet: "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark", NokiaLumiaTablet: "Lumia 2520", SonyTablet: "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712", PhilipsTablet: "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b", CubeTablet: "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT", CobyTablet: "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010", MIDTablet: "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10", MSITablet: "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b", SMiTTablet: "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)", RockChipTablet: "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A", FlyTablet: "IQ310|Fly Vision", bqTablet: "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus", HuaweiTablet: "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19", NecTablet: "\\bN-06D|\\bN-08D", PantechTablet: "Pantech.*P4100", BronchoTablet: "Broncho.*(N701|N708|N802|a710)", VersusTablet: "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b", ZyncTablet: "z1000|Z99 2G|z930|z990|z909|Z919|z900", PositivoTablet: "TB07STA|TB10STA|TB07FTA|TB10FTA", NabiTablet: "Android.*\\bNabi", KoboTablet: "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build", DanewTablet: "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b", TexetTablet: "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE", PlaystationTablet: "Playstation.*(Portable|Vita)", TrekstorTablet: "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab", PyleAudioTablet: "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b", AdvanTablet: "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ", DanyTechTablet: "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1", GalapadTablet: "Android [0-9.]+; [a-z-]+; \\bG1\\b", MicromaxTablet: "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b", KarbonnTablet: "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b", AllFineTablet: "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide", PROSCANTablet: "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b", YONESTablet: "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026", ChangJiaTablet: "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503", GUTablet: "TX-A1301|TX-M9002|Q702|kf026", PointOfViewTablet: "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10", OvermaxTablet: "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027", HCLTablet: "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync", DPSTablet: "DPS Dream 9|DPS Dual 7", VistureTablet: "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10", CrestaTablet: "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989", MediatekTablet: "\\bMT8125|MT8389|MT8135|MT8377\\b", ConcordeTablet: "Concorde([ ]+)?Tab|ConCorde ReadMan", GoCleverTablet: "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042", ModecomTablet: "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003", VoninoTablet: "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b", ECSTablet: "V07OT2|TM105A|S10OT1|TR10CS1", StorexTablet: "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab", VodafoneTablet: "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400", EssentielBTablet: "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2", RossMoorTablet: "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711", iMobileTablet: "i-mobile i-note", TolinoTablet: "tolino tab [0-9.]+|tolino shine", AudioSonicTablet: "\\bC-22Q|T7-QC|T-17B|T-17P\\b", AMPETablet: "Android.* A78 ", SkkTablet: "Android.* (SKYPAD|PHOENIX|CYCLOPS)", TecnoTablet: "TECNO P9|TECNO DP8D", JXDTablet: "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b", iJoyTablet: "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)", FX2Tablet: "FX2 PAD7|FX2 PAD10", XoroTablet: "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151", ViewsonicTablet: "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a", VerizonTablet: "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1", OdysTablet: "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10", CaptivaTablet: "CAPTIVA PAD", IconbitTablet: "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S", TeclastTablet: "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi", OndaTablet: "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b", JaytechTablet: "TPC-PA762", BlaupunktTablet: "Endeavour 800NG|Endeavour 1010", DigmaTablet: "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b", EvolioTablet: "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b", LavaTablet: "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b", AocTablet: "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712", MpmanTablet: "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010", CelkonTablet: "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b", WolderTablet: "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b", MediacomTablet: "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA", MiTablet: "\\bMI PAD\\b|\\bHM NOTE 1W\\b", NibiruTablet: "Nibiru M1|Nibiru Jupiter One", NexoTablet: "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI", LeaderTablet: "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100", UbislateTablet: "UbiSlate[\\s]?7C", PocketBookTablet: "Pocketbook", KocasoTablet: "\\b(TB-1207)\\b", HisenseTablet: "\\b(F5281|E2371)\\b", Hudl: "Hudl HT7S3|Hudl 2", TelstraTablet: "T-Hub2", GenericTablet: "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107" }, oss: { AndroidOS: "Android", BlackBerryOS: "blackberry|\\bBB10\\b|rim tablet os", PalmOS: "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino", SymbianOS: "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b", WindowsMobileOS: "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;", WindowsPhoneOS: "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;", iOS: "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia", iPadOS: "CPU OS 13", SailfishOS: "Sailfish", MeeGoOS: "MeeGo", MaemoOS: "Maemo", JavaOS: "J2ME/|\\bMIDP\\b|\\bCLDC\\b", webOS: "webOS|hpwOS", badaOS: "\\bBada\\b", BREWOS: "BREW" }, uas: { Chrome: "\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?", Dolfin: "\\bDolfin\\b", Opera: "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+$|Coast/[0-9.]+", Skyfire: "Skyfire", Edge: "\\bEdgiOS\\b|Mobile Safari/[.0-9]* Edge", IE: "IEMobile|MSIEMobile", Firefox: "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS", Bolt: "bolt", TeaShark: "teashark", Blazer: "Blazer", Safari: "Version((?!\\bEdgiOS\\b).)*Mobile.*Safari|Safari.*Mobile|MobileSafari", WeChat: "\\bMicroMessenger\\b", UCBrowser: "UC.*Browser|UCWEB", baiduboxapp: "baiduboxapp", baidubrowser: "baidubrowser", DiigoBrowser: "DiigoBrowser", Mercury: "\\bMercury\\b", ObigoBrowser: "Obigo", NetFront: "NF-Browser", GenericBrowser: "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger", PaleMoon: "Android.*PaleMoon|Mobile.*PaleMoon" }, props: { Mobile: "Mobile/[VER]", Build: "Build/[VER]", Version: "Version/[VER]", VendorID: "VendorID/[VER]", iPad: "iPad.*CPU[a-z ]+[VER]", iPhone: "iPhone.*CPU[a-z ]+[VER]", iPod: "iPod.*CPU[a-z ]+[VER]", Kindle: "Kindle/[VER]", Chrome: ["Chrome/[VER]", "CriOS/[VER]", "CrMo/[VER]"], Coast: ["Coast/[VER]"], Dolfin: "Dolfin/[VER]", Firefox: ["Firefox/[VER]", "FxiOS/[VER]"], Fennec: "Fennec/[VER]", Edge: "Edge/[VER]", IE: ["IEMobile/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident/[0-9.]+;.*rv:[VER]"], NetFront: "NetFront/[VER]", NokiaBrowser: "NokiaBrowser/[VER]", Opera: [" OPR/[VER]", "Opera Mini/[VER]", "Version/[VER]"], "Opera Mini": "Opera Mini/[VER]", "Opera Mobi": "Version/[VER]", UCBrowser: ["UCWEB[VER]", "UC.*Browser/[VER]"], MQQBrowser: "MQQBrowser/[VER]", MicroMessenger: "MicroMessenger/[VER]", baiduboxapp: "baiduboxapp/[VER]", baidubrowser: "baidubrowser/[VER]", SamsungBrowser: "SamsungBrowser/[VER]", Iron: "Iron/[VER]", Safari: ["Version/[VER]", "Safari/[VER]"], Skyfire: "Skyfire/[VER]", Tizen: "Tizen/[VER]", Webkit: "webkit[ /][VER]", PaleMoon: "PaleMoon/[VER]", SailfishBrowser: "SailfishBrowser/[VER]", Gecko: "Gecko/[VER]", Trident: "Trident/[VER]", Presto: "Presto/[VER]", Goanna: "Goanna/[VER]", iOS: " \\bi?OS\\b [VER][ ;]{1}", Android: "Android [VER]", Sailfish: "Sailfish [VER]", BlackBerry: ["BlackBerry[\\w]+/[VER]", "BlackBerry.*Version/[VER]", "Version/[VER]"], BREW: "BREW [VER]", Java: "Java/[VER]", "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"], "Windows Phone": "Windows Phone [VER]", "Windows CE": "Windows CE/[VER]", "Windows NT": "Windows NT [VER]", Symbian: ["SymbianOS/[VER]", "Symbian/[VER]"], webOS: ["webOS/[VER]", "hpwOS/[VER];"] }, utils: { Bot: "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp|AspiegelBot", MobileBot: "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2", DesktopMode: "WPDesktop", TV: "SonyDTV|HbbTV", WebKit: "(webkit)[ /]([\\w.]+)", Console: "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b", Watch: "SM-V700" } }, detectMobileBrowsers: { fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, tabletPattern: /android|ipad|playbook|silk/i } }, s = Object.prototype.hasOwnProperty; return a.FALLBACK_PHONE = "UnknownPhone", a.FALLBACK_TABLET = "UnknownTablet", a.FALLBACK_MOBILE = "UnknownMobile", o = "isArray" in Array ? Array.isArray : function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, function () { var e, t, i, n, c, l, d = a.mobileDetectRules; for (e in d.props) if (s.call(d.props, e)) { for (t = d.props[e], o(t) || (t = [t]), c = t.length, n = 0; n < c; ++n)(l = (i = t[n]).indexOf("[VER]")) >= 0 && (i = i.substring(0, l) + "([\\w._\\+]+)" + i.substring(l + 5)), t[n] = new RegExp(i, "i"); d.props[e] = t } r(d.oss), r(d.phones), r(d.tablets), r(d.uas), r(d.utils), d.oss0 = { WindowsPhoneOS: d.oss.WindowsPhoneOS, WindowsMobileOS: d.oss.WindowsMobileOS } }(), a.findMatch = function (e, t) { for (var r in e) if (s.call(e, r) && e[r].test(t)) return r; return null }, a.findMatches = function (e, t) { var r = []; for (var i in e) s.call(e, i) && e[i].test(t) && r.push(i); return r }, a.getVersionStr = function (e, t) { var r, i, n, o, c = a.mobileDetectRules.props; if (s.call(c, e)) for (n = (r = c[e]).length, i = 0; i < n; ++i)if (null !== (o = r[i].exec(t))) return o[1]; return null }, a.getVersion = function (e, t) { var r = a.getVersionStr(e, t); return r ? a.prepareVersionNo(r) : NaN }, a.prepareVersionNo = function (e) { var t; return 1 === (t = e.split(/[a-z._ \/\-]/i)).length && (e = t[0]), t.length > 1 && (e = t[0] + ".", t.shift(), e += t.join("")), Number(e) }, a.isMobileFallback = function (e) { return a.detectMobileBrowsers.fullPattern.test(e) || a.detectMobileBrowsers.shortPattern.test(e.substr(0, 4)) }, a.isTabletFallback = function (e) { return a.detectMobileBrowsers.tabletPattern.test(e) }, a.prepareDetectionCache = function (e, t, r) { var o, s, c; if (e.mobile === i) return (s = a.findMatch(a.mobileDetectRules.tablets, t)) ? (e.mobile = e.tablet = s, void (e.phone = null)) : (o = a.findMatch(a.mobileDetectRules.phones, t)) ? (e.mobile = e.phone = o, void (e.tablet = null)) : void (a.isMobileFallback(t) ? (c = n.isPhoneSized(r), c === i ? (e.mobile = a.FALLBACK_MOBILE, e.tablet = e.phone = null) : c ? (e.mobile = e.phone = a.FALLBACK_PHONE, e.tablet = null) : (e.mobile = e.tablet = a.FALLBACK_TABLET, e.phone = null)) : a.isTabletFallback(t) ? (e.mobile = e.tablet = a.FALLBACK_TABLET, e.phone = null) : e.mobile = e.tablet = e.phone = null) }, a.mobileGrade = function (e) { var t = null !== e.mobile(); return e.os("iOS") && e.version("iPad") >= 4.3 || e.os("iOS") && e.version("iPhone") >= 3.1 || e.os("iOS") && e.version("iPod") >= 3.1 || e.version("Android") > 2.1 && e.is("Webkit") || e.version("Windows Phone OS") >= 7 || e.is("BlackBerry") && e.version("BlackBerry") >= 6 || e.match("Playbook.*Tablet") || e.version("webOS") >= 1.4 && e.match("Palm|Pre|Pixi") || e.match("hp.*TouchPad") || e.is("Firefox") && e.version("Firefox") >= 12 || e.is("Chrome") && e.is("AndroidOS") && e.version("Android") >= 4 || e.is("Skyfire") && e.version("Skyfire") >= 4.1 && e.is("AndroidOS") && e.version("Android") >= 2.3 || e.is("Opera") && e.version("Opera Mobi") > 11 && e.is("AndroidOS") || e.is("MeeGoOS") || e.is("Tizen") || e.is("Dolfin") && e.version("Bada") >= 2 || (e.is("UC Browser") || e.is("Dolfin")) && e.version("Android") >= 2.3 || e.match("Kindle Fire") || e.is("Kindle") && e.version("Kindle") >= 3 || e.is("AndroidOS") && e.is("NookTablet") || e.version("Chrome") >= 11 && !t || e.version("Safari") >= 5 && !t || e.version("Firefox") >= 4 && !t || e.version("MSIE") >= 7 && !t || e.version("Opera") >= 10 && !t ? "A" : e.os("iOS") && e.version("iPad") < 4.3 || e.os("iOS") && e.version("iPhone") < 3.1 || e.os("iOS") && e.version("iPod") < 3.1 || e.is("Blackberry") && e.version("BlackBerry") >= 5 && e.version("BlackBerry") < 6 || e.version("Opera Mini") >= 5 && e.version("Opera Mini") <= 6.5 && (e.version("Android") >= 2.3 || e.is("iOS")) || e.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3") || e.version("Opera Mobi") >= 11 && e.is("SymbianOS") ? "B" : (e.version("BlackBerry") < 5 || e.match("MSIEMobile|Windows CE.*Mobile") || e.version("Windows Mobile"), "C") }, a.detectOS = function (e) { return a.findMatch(a.mobileDetectRules.oss0, e) || a.findMatch(a.mobileDetectRules.oss, e) }, a.getDeviceSmallerSide = function () { return window.screen.width < window.screen.height ? window.screen.width : window.screen.height }, n.prototype = { constructor: n, mobile: function () { return a.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.mobile }, phone: function () { return a.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.phone }, tablet: function () { return a.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.tablet }, userAgent: function () { return this._cache.userAgent === i && (this._cache.userAgent = a.findMatch(a.mobileDetectRules.uas, this.ua)), this._cache.userAgent }, userAgents: function () { return this._cache.userAgents === i && (this._cache.userAgents = a.findMatches(a.mobileDetectRules.uas, this.ua)), this._cache.userAgents }, os: function () { return this._cache.os === i && (this._cache.os = a.detectOS(this.ua)), this._cache.os }, version: function (e) { return a.getVersion(e, this.ua) }, versionStr: function (e) { return a.getVersionStr(e, this.ua) }, is: function (r) { return t(this.userAgents(), r) || e(r, this.os()) || e(r, this.phone()) || e(r, this.tablet()) || t(a.findMatches(a.mobileDetectRules.utils, this.ua), r) }, match: function (e) { return e instanceof RegExp || (e = new RegExp(e, "i")), e.test(this.ua) }, isPhoneSized: function (e) { return n.isPhoneSized(e || this.maxPhoneWidth) }, mobileGrade: function () { return this._cache.grade === i && (this._cache.grade = a.mobileGrade(this)), this._cache.grade } }, "undefined" != typeof window && window.screen ? n.isPhoneSized = function (e) { return e < 0 ? i : a.getDeviceSmallerSide() <= e } : n.isPhoneSized = function () { }, n._impl = a, n.version = "1.4.5 2021-03-13", n })) }, 129: (e, t, r) => { var i, n = null; function o(e, t) { try { zteWebrtc.log(e, t) } catch (t) { console.log(t), console.log(e) } } webrtcDetect = function () { this.envirDet = { systemVersion: "", browserTypeVer: "", browserKernelUA: "", screenResolution: { w: 0, h: 0 }, logicalProcNum: 0, webrtcSdkVer: "" }, this.abilityDet = { isPass: !0, supportWASM: !1, supportWebCodec: !1, supportSharedBuffer: !1, webrtcSupport: !1, websocketSupport: !1, videoSupport: !1, ReplaceTracks: !1, deviceSupport: !1, h264Encoding: !1, h264Decoding: !1, screenSharing: !1, multDisplay: !1 }, this.deviceDet = { cameraAllowed: !1, microphoneAllowed: !1, audioinputArr: [], audiooutputArr: [], videoinputArr: [] }, this.checkFlage = !1, this.terminalType = "pc", this.audioContext = null, this.canvasCtx_ = null, this.audioStream = null, this.audioConstraints = null, this.videoEle = null, this.videoStream = null, this.videoConstrains = null, this.front = !0, this.speakerEle = null }, webrtcDetect.prototype = { getEnvirResult: function () { var e = this; e.envirDet.systemVersion = e.getSystemVer(); var t = e.getBrowserTypeVer(); e.envirDet.browserTypeVer = t.name + "/" + t.fullVersion, "Chrome" != t.name && (e.envirDet.browserTypeVer += "  (Chrome!)"), e.envirDet.browserKernelUA = e.getBrowserUA(); var r = e.getResolution(); return e.envirDet.screenResolution.w = r.screenWidth, e.envirDet.screenResolution.h = r.screenHeight, e.envirDet.logicalProcNum = e.getLogicalProcNum(), e.envirDet.webrtcSdkVer = e.getWebrtcSdkVer(), e.envirDet }, getAbilityResult: function () { var e = this; return e.abilityDet.webrtcSupport = e.getWebrtcSupport(), e.abilityDet.websocketSupport = e.getWebsocketSupport(), e.abilityDet.videoSupport = e.getVideoSupport(), e.abilityDet.ReplaceTracks = e.getReplaceTracks(), e.abilityDet.deviceSupport = e.getDeviceSupport(), e.abilityDet.h264Encoding = e.getH264Encoding(), e.abilityDet.h264Decoding = e.getH264Decoding(), e.abilityDet.screenSharing = e.getScreenShare(), e.abilityDet.multDisplay = e.getMultiDisplay(), e.abilityDet.supportWASM = e.getWASMSupport(), e.abilityDet.supportWebCodec = e.getCodecSupport(), e.abilityDet.supportSharedBuffer = e.getSharedBuff(), this.abilityDet }, getDevResult: async function (e) { return this.getDevice(e), this.deviceDet }, detectRun: function (e, t = !1) { var r = this; r.webrtcMulti = t, r.getEnvirResult(), r.getAbilityResult(), r.getDevResult(e) }, getSystemVer: function () { let e = this; var t = navigator.userAgent; if (t.indexOf("Android") > -1) { e.terminalType = "mobile"; let r = t.indexOf("Android"); return t.substring(r).indexOf(";") ? t.substring(r).split(";")[0] : "Android" } if (t.indexOf("iPhone") > -1) return e.terminalType = "mobile", "iPhone"; var r = "Win32" == navigator.platform || "Windows" == navigator.platform, i = "Mac68K" == navigator.platform || "MacPPC" == navigator.platform || "Macintosh" == navigator.platform || "MacIntel" == navigator.platform; if (i) return "Mac"; if ("X11" == navigator.platform && !r && !i) return "Unix"; if (String(navigator.platform).indexOf("Linux") > -1) return "Linux"; if (r) { if (t.indexOf("Windows NT 5.0") > -1 || t.indexOf("Windows 2000") > -1) return "Win2000"; if (t.indexOf("Windows NT 5.1") > -1 || t.indexOf("Windows XP") > -1) return "WinXP"; if (t.indexOf("Windows NT 5.2") > -1 || t.indexOf("Windows 2003") > -1) return "Win2003"; if (t.indexOf("Windows NT 6.0") > -1 || t.indexOf("Windows Vista") > -1) return "WinVista"; if (t.indexOf("Windows NT 6.1") > -1 || t.indexOf("Windows 7") > -1) return "Win7"; if (t.indexOf("Windows NT 10") > -1 || t.indexOf("Windows 10") > -1) return "Win10" } return "" }, check360: function () { for (var e in navigator.plugins) if ("internal-nacl-plugin" == navigator.plugins[e].filename) return !0; return !1 }, getBrowserTypeVer: function () { navigator.product, navigator.productSub, navigator.vendor, navigator.venderSub, navigator.javaEnabled(); var e = navigator.userAgent.toLowerCase(), t = !1; -1 != e.indexOf("micromessenger") && (t = !0, o("isWeixin", "info")); var r, i = !1; -1 == e.indexOf("tencenttraveler") && -1 == e.indexOf("qqbrowser") || (i = !0), r = this.check360(), console.log("weixin:", t, "is360:", r, "isqq:", i), /Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ""); var n, a, s, c = -1 !== navigator.userAgent.indexOf(" Edg"), l = !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0, d = navigator.userAgent.toLowerCase().indexOf("Firefox") > -1 && "netscape" in window && / rv:/.test(navigator.userAgent), u = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), p = !!window.chrome && !l && !c && -1 !== navigator.userAgent.indexOf("Chrome"), g = "undefined" != typeof document && !!document.documentMode && !c, f = (navigator.appVersion, navigator.userAgent), h = navigator.appName, m = "" + parseFloat(navigator.appVersion), S = parseInt(navigator.appVersion, 10); if (l) { h = "Opera"; try { S = (m = navigator.userAgent.split("OPR/")[1].split(" ")[0]).split(".")[0] } catch (e) { m = "0.0.0.0", S = 0 } } else g ? ((a = f.indexOf("rv:")) > 0 ? m = f.substring(a + 3) : (a = f.indexOf("MSIE"), m = f.substring(a + 5)), h = "IE") : p ? (a = f.indexOf("Chrome"), h = "Chrome", m = f.substring(a + 7)) : u ? -1 !== f.indexOf("CriOS") ? (a = f.indexOf("CriOS"), h = "Chrome", m = f.substring(a + 6)) : -1 !== f.indexOf("FxiOS") ? (a = f.indexOf("FxiOS"), h = "Firefox", m = f.substring(a + 6)) : (a = f.indexOf("Safari"), h = "Safari", m = f.substring(a + 7), -1 !== (a = f.indexOf("Version")) && (m = f.substring(a + 8)), -1 !== navigator.userAgent.indexOf("Version/") && (m = navigator.userAgent.split("Version/")[1].split(" ")[0])) : d ? (a = f.indexOf("Firefox"), h = "Firefox", m = f.substring(a + 8)) : (n = f.lastIndexOf(" ") + 1) < (a = f.lastIndexOf("/")) && (h = f.substring(n, a), m = f.substring(a + 1), h.toLowerCase() === h.toUpperCase() && (h = navigator.appName)); if (c && (h = "Edge", m = navigator.userAgent.split("Edg/")[1]), -1 !== (s = m.search(/[; \)]/)) && (m = m.substring(0, s)), S = parseInt("" + m, 10), isNaN(S) && (m = "" + parseFloat(navigator.appVersion), S = parseInt(navigator.appVersion, 10)), i) { h = "QQ"; let t = e.substring(e.indexOf("qqbrowser")), r = t.indexOf(" "); m = r > 0 ? t.substring(t.indexOf("/") + 1, r) : t.substring(t.indexOf("/") + 1), S = t.substring(t.indexOf("/") + 1, t.indexOf(".")), console.log("qqVsersion:", m) } else if (r) h = "360"; else if (t) { h = "WeiXin"; let t = e.substring(e.indexOf("micromessenger")); console.log("weixin:", t); let r = t.indexOf(" "); r > 0 ? (m = t.substring(t.indexOf("/") + 1, r)).indexOf("(") > -1 && (m = m.substring(0, m.indexOf("("))) : m = t.substring(t.indexOf("/") + 1), S = t.substring(t.indexOf("/") + 1, t.indexOf(".")), console.log("weixinVsersion:", m) } if (e.indexOf("baiduboxapp") > 0) { h = "BaiDu", console.log("baiduV:", e.indexOf("baiduboxapp")); let t = e.indexOf("baiduboxapp"); if (t > 0) { let r = e.substring(t); console.log("isBuDu:", r); let i = r.indexOf(" "), n = r.indexOf("."), o = i || n; m = r.substring(r.indexOf("/") + 1, o), S = r.substring(r.indexOf("/") + 1, n), console.log("baiduversion:", m) } } let b = e.indexOf("huaweibrowser"), T = e.indexOf("harmonyos"); if ((b > 0 || T > 0) && (console.log("isHarmonyOS"), h = "harmonyOS", b > 0)) { let t = e.substring(b), r = t.indexOf("/"), i = t.indexOf("."), n = t.indexOf(" ") || i; m = t.substring(r + 1, n), S = t.substring(r + 1, i) } return { fullVersion: m, version: S, name: h, isPrivateBrowsing: !1 } }, getBrowserUA: function () { var e = navigator.userAgent; return "string" == typeof e && e.length > 0 ? e : "" }, getResolution: function () { var e = 0, t = 0; return window.screen ? { screenWidth: e = window.screen.width, screenHeight: t = window.screen.height } : (window.innerWidth ? e = window.innerWidth : document.body && document.body.clientWidth && (t = document.body.clientWidth), window.innerHeight ? e = window.innerHeight : document.body && document.body.clientHeight && (t = document.body.clientHeight), document.documentElement && document.documentElement.clientHeight && document.documentElement.clientWidth && (t = document.documentElement.clientHeight, e = document.documentElement.clientWidth), { screenWidth: e, screenHeight: t }) }, getLogicalProcNum: function () { return navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 2 }, getWebrtcSdkVer: function () { var e = zteWebrtc.getVersion(); return "failed" === e ? "" : e }, getWebrtcSupport: function () { var e = this; if (e.webrtcMulti) return !0; try { return !!(window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.RTCIceGatherer) || (e.abilityDet.isPass = !1, !1) } catch (t) { return e.abilityDet.isPass = !1, !1 } }, getWASMSupport: function () { var e = this; if (!e.webrtcMulti) return !0; try { if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate) { const e = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)); if (e instanceof WebAssembly.Module && new WebAssembly.Instance(e) instanceof WebAssembly.Instance) return console.log("getWASMSupport yes"), !0 } } catch (t) { return e.abilityDet.isPass = !1, !1 } return e.abilityDet.isPass = !1, !1 }, getCodecSupport: function () { var e = this; if (!e.webrtcMulti) return !0; try { let t = new VideoDecoder({ output: function () { console.log("VideoDecoder.output") }, error: function () { console.error("VideoDecoder.error") } }), r = new VideoEncoder({ output: function () { console.log("VideoEncoder.output") }, error: function () { console.error("VideoEncoder.error") } }); return t && r ? (console.log("getCodecSupport ok"), !0) : (e.abilityDet.isPass = !1, !1) } catch (t) { return e.abilityDet.isPass = !1, console.log("new VideoDecoder err:", t), !1 } }, getSharedBuff: function () { return !(this.webrtcMulti && "function" != typeof SharedArrayBuffer && (this.abilityDet.isPass = !1, 1)) }, getWebsocketSupport: function () { var e = !1; return "WebSocket" in window && 2 === window.WebSocket.CLOSING && (e = !0), 0 == e && (this.abilityDet.isPass = !1), e }, getVideoSupport: function () { var e = !1; try { var t = document.createElement("VIDEO"); t.setAttribute("width", "16"), t.setAttribute("height", "16"), t.setAttribute("controls", "controls"), e = !0 } catch (t) { e = !1 } return 0 == e && (this.abilityDet.isPass = !1), e }, getReplaceTracks: function () { if (this.webrtcMulti) return !0; -1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveOrOpenBlob && navigator.msSaveBlob; var e = !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0, t = navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && "netscape" in window && / rv:/.test(navigator.userAgent), r = (/^((?!chrome|android).)*safari/i.test(navigator.userAgent), !!window.chrome && !e), i = ("undefined" != typeof document && document.documentMode, !1); return t && "undefined" != typeof mozRTCPeerConnection ? "getSenders" in mozRTCPeerConnection.prototype && (i = !0) : r && "undefined" != typeof webkitRTCPeerConnection && "getSenders" in webkitRTCPeerConnection.prototype && (i = !0), 0 == i && (this.abilityDet.isPass = !1), i }, getDeviceSupport: function () { return !!(navigator.mediaDevices && (navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.getUserMedia) && navigator.mediaDevices.enumerateDevices) || (this.abilityDet.isPass = !1, !1) }, getH264Encoding: function () { let e = null, t = !1; try { if (e = RTCRtpSender.getCapabilities("video"), null != e) for (elem of e.codecs) "video/H264" === elem.mimeType && (t = !0) } catch (e) { o("[getH264Encoding]" + e.message, "info") } return 1 == t || (this.abilityDet.isPass = !1, !1) }, getH264Decoding: function () { let e = null, t = !1; try { if (e = RTCRtpReceiver.getCapabilities("video"), null != e) for (elem of e.codecs) "video/H264" === elem.mimeType && (t = !0) } catch (e) { o("[getH264Decoding]" + e.message, "info") } return 1 == t || (this.abilityDet.isPass = !1, !1) }, getScreenShare: function () { var e = !1; if (/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || "")) return this.abilityDet.isPass = !1, e; var t = this.getBrowserTypeVer(); o("[browserInfo]" + JSON.stringify(t), "info"); var r = !(-1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveOrOpenBlob && !navigator.msSaveBlob), i = !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0, n = navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && "netscape" in window && / rv:/.test(navigator.userAgent), a = (/^((?!chrome|android).)*safari/i.test(navigator.userAgent), !!window.chrome && !i); return "undefined" != typeof document && document.documentMode, (a && t.version >= 72 || n && t.version >= 66 || r && t.version >= 79) && (e = !0), (navigator.getDisplayMedia || navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (e = !0), /^(https:|chrome-extension:)$/g.test(location.protocol || "") || ("undefined" != typeof document && "string" == typeof document.domain && document.domain.search && -1 === document.domain.search(/localhost|127.0./g) && (t.isChrome || t.isEdge || t.isOpera) || n) && (e = !1), 0 == e && (this.abilityDet.isPass = !1), e }, getMultiDisplay: function () { var e = !1; return /Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || "") ? (this.abilityDet.isPass = !1, e) : ((navigator.getDisplayMedia || navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (e = !0), e) }, enumerDevice: function (e, t) { var r = this; navigator.mediaDevices.enumerateDevices().then((function (i) { r.deviceDet.microphoneAllowed = !1, r.deviceDet.audioinputArr = [], r.deviceDet.audiooutputArr = [], r.deviceDet.cameraAllowed = !1, r.deviceDet.videoinputArr = [], o("[detectRTC.enumerDevice]" + i.toString(), "info"); for (let e = 0; e !== i.length; ++e) { const t = i[e]; o("kind:" + t.kind + ",label:" + t.label + ",deviceid:" + t.deviceId, "info"), "audioinput" === t.kind ? (r.deviceDet.microphoneAllowed = !0, r.deviceDet.audioinputArr.push(t)) : "audiooutput" === t.kind ? r.deviceDet.audiooutputArr.push(t) : "videoinput" === t.kind ? (r.deviceDet.cameraAllowed = !0, r.deviceDet.videoinputArr.push(t)) : o("[detectRTC]get devices other kind", "info") } return "Permission" == t && (r.deviceDet.microphoneAllowed = !1, r.deviceDet.cameraAllowed = !1), e(r), r.checkFlage = !0, !0 })).catch((t => (e(r), r.checkFlage = !0, o("[detectRTC.enumerateDevices]" + t.message || 0, "info"), !1))) }, getDevice: async function (e) { var t = this; try { navigator.mediaDevices.ondevicechange = function (r) { if (t.enumerDevice(e, ""), null != t.canvasCtx_) { if (t.deviceDet.audioinputArr.length > 0) { let e = t.deviceDet.audioinputArr[0].deviceId; t.setMicroPhone(e) } } else if (null != t.speakerEle) { if (t.deviceDet.audiooutputArr.length > 0) { let e = t.deviceDet.audiooutputArr[0].deviceId; t.setSpeaker(e) } } else if (null != t.videoStream && t.deviceDet.videoinputArr.length > 0) { let e = t.deviceDet.videoinputArr[0].deviceId; t.setCamera(e) } }, navigator.mediaDevices.getUserMedia({ video: !0, audio: !0 }).then((r => { o("[detectRTC.getDevice1]", "info"), t.enumerDevice(e, "") })).catch((r => { "Permission denied" == r.message || -1 != r.message.indexOf("not allowed") ? t.enumerDevice(e, "Permission") : t.enumerDevice(e, ""), o("[detectRTC.getDevice2]" + r.message, "warn") })) } catch (r) { return t.enumerDevice(e, ""), o("[detectRTC.getDevices3] err" + r.message, "warn"), !1 } }, GetUserMedia: function (e, t) { navigator.mediaDevices.getUserMedia ? navigator.mediaDevices.getUserMedia(e).then(t).catch((t => { o("[detectRTC.getuserMedia]" + e.toString() + t.message || 0, "info") })) : navigator.webkitGetUserMedia ? navigator.webkitGetUserMedia(e).then(t).catch((t => { o("[detectRTC.getuserMedia]" + e.toString() + t.message || 0, "info") })) : navigator.mozGetUserMedia ? navagator.mozGetUserMedia(e).then(t).catch((t => { o("[detectRTC.getuserMedia]" + e.toString() + t.message || 0, "info") })) : navigator.getUserMedia && navigator.getUserMedia(e).then(t).catch((t => { o("[detectRTC.getuserMedia]" + e.toString() + t.message || 0, "info") })) }, testCamera: function (e, t) { var r = this; if (null == e) return o("[detectRTC.testCamera] videoEle is null.", "warn"), !1; r.videoEle = e, r.videoConstrains = { video: { width: { ideal: 480 }, height: { ideal: 320 }, frameRate: 30, aspectRatio: 16 / 9, resizeMode: "crop-and-scale" }, audio: !1 }, "" != t && (r.videoConstrains.video.deviceId = t), o("[detectRTC]camera is being played on:" + t, "info"), r.GetUserMedia(r.videoConstrains, r.videoStreamf) }, videoStreamf: function (e) { o("[detectRTC.videoStreamf]", "info"), n.videoStream = e, n.videoEle.srcObject = e, n.videoEle.play() }, freeCamrea: function () { var e = this; null != e.videoStream ? (e.videoStream.getVideoTracks().forEach((function (t) { t.stop(), e.videoStream.removeTrack(t), t.enabled = !t.enabled })), o("[detectRTC]freeCamrea success", "info")) : o("[detectRTC]freeCamrea videoStream is null", "info"), e.videoEle = null, e.videoStream = null, e.videoConstrains = null }, setCamera: function (e) { var t = this; if (o("[detectRTC.setCamera] " + e, "info"), null === t.videoStream) return o("[detectRTC.setCamera] old videoStream is null", "info"), !1; if (null === t.videoConstrains) return o("[detectRTC.setCamera] old videoConstrains is null", "info"), !1; t.videoConstrains.video.deviceId = e || void 0; let r = { video: t.videoConstrains.video, audio: !1 }; navigator.mediaDevices.getUserMedia(r).then((function (e) { let r = e.getVideoTracks()[0], i = t.videoStream.getVideoTracks()[0]; i.stop(), t.videoStream.removeTrack(i), t.videoStream.addTrack(r) })).catch((function (e) { o("[detectRTC.setCamera] getUserMedia: " + e, "error"), navigator.mediaDevices.getUserMedia({ video: t.videoConstrains.video, audio: !1 }).then(t.videoStreamf).catch((e => { o("[detectRTC.setCamera] getUserMedia2: " + e, "error") })) })) }, testMicrophone: function (e, t) { if (null == e) return o("[detectRTC.testMicrophone]canvasCtx is null;device:" + t, "warn"), !1; var r = this; r.freeMicrophone().then((() => { r.canvasCtx_ = e, r.audioConstraints = { audio: !0, video: !1 }, "" != t && (r.audioConstraints = { audio: { deviceId: t }, video: !1 }), o("[detectRTC.testMicrophone]microphone is being played on:" + t, "info"), r.GetUserMedia(r.audioConstraints, r.audioStreamf) })) }, audioStreamf: function (e) { n.audioStream = e; try { n.showAudio() } catch (e) { o("[detectRTC.audioStreamf]:" + e.message, "info"), n.showAudio(), n.audioContext = null, n.audioStream = null } }, showAudio: function () { var e = this; try { e.audioContext = null; var t = window.AudioContext || window.webkitAudioContext || window.mozAudioContext; e.audioContext = new t; var r = "[object MediaStream]" !== Object.prototype.toString.call(e.audioStream) ? e.audioContext.createMediaElementSource(e.audioStream) : e.audioContext.createMediaStreamSource(e.audioStream), i = e.audioContext.createAnalyser(); r.connect(i), i.fftSize = 256, i.connect(e.audioContext.destination), function (e, t) { if (null == t) return o("visualize_ canvasctx is null", "warn"), !1; var r = e.frequencyBinCount, i = new Uint8Array(r); t.clearRect(0, 0, 300, 150); var n = function () { var o; drawVisual = requestAnimationFrame(n), e.getByteFrequencyData(i), t.fillStyle = "rgb(229, 229, 229)", t.fillRect(0, 0, 300, 150); for (var a = 0; a < r; a++)o = i[a], t.fillStyle = "rgb(0, 134, 209)", t.fillRect(0, 0, o / 2, 150) }; n() }(i, e.canvasCtx_) } catch (e) { o("[detectRTC.showAudio]:" + e.message, "info") } }, freeAudiStrem: function () { var e = this; null != e.audioStream ? (e.audioStream.getVideoTracks().forEach((function (t) { t.stop(), e.audioStream.removeTrack(t), t.enabled = !t.enabled })), e.audioStream = null, o("[detectRTC] freeMicrophone track success", "info")) : o("[detectRTC] freeMicrophone audioStream is null", "info") }, freeMicrophone: function () { var e = this; return new Promise(((t, r) => { e.audioConstraints = null, e.canvasCtx_ = null, null != e.audioContext ? e.audioContext.close().then((function () { o("[detectRTC] freeMicrophone close audioContext success", "info"), e.audioContext = null, e.freeAudiStrem(), t() })).catch((r => { e.audioContext = null, o("[detectRTC] freeMicrophone audioContext failed:" + r.message, "warn"), e.freeAudiStrem(), t() })) : (o("[detectRTC] freeMicrophone audioContext is null", "info"), e.freeAudiStrem(), t()) })) }, setMicroPhone(e) { var t = this; return "" === e ? (o("[detectRTC.setMicroPhone] microDevice is null", "info"), !1) : null === t.canvasCtx_ ? (o("[detectRTC.setMicroPhone] canvasCtx_ is null", "info"), !1) : (o("[detectRTC.setMicroPhone] " + e, "info"), t.audioConstraints.audio.deviceId = e || void 0, void navigator.mediaDevices.getUserMedia({ audio: t.audioConstraints.audio, video: !1 }).then((function (e) { if (null != t.audioStream) { let r = e.getAudioTracks()[0], i = t.audioStream.getAudioTracks()[0]; i.stop(), t.audioStream.removeTrack(i), t.audioStream.addTrack(r) } else t.audioStream = e; null != t.audioContext ? t.audioContext.close().then((function () { o("[detectRTC] setMicroPhone close audioContext success", "info"), t.showAudio() })).catch((e => { o("[detectRTC] setMicroPhone audioContext failed:" + e.message, "info") })) : (o("[detectRTC] setMicroPhone audioContext is null", "info"), t.showAudio()) })).catch((function (r) { o("[detectRTC.setMicroPhone] getUserMedia: " + r, "info"), -1 != r.indexOf("NotReadableError") && t.setMicroPhone(e) }))) }, testSpeaker: function (e, t, r = "pc") { var i = this; return e ? (i.speakerEle = e, "mobile" != r && "mobile" != i.terminalType ? "" != t ? (i.speakerEle.setSinkId(t).then((() => { o("[detectRTC.testSpeaker] success on:" + t, "info") })).catch((e => { o("[detectRTC.testSpeaker] filed on:" + t + " " + e, "warn") })), !0) : (o("[detectRTC.testSpeaker] deviceId is null", "info"), !1) : void 0) : (o("[detectRTC.testSpeaker] speaker is null", "info"), !1) }, freeSpeaker: function () { var e = this; if (null === e.speakerEle) return o("[detectRTC.freeSpeaker] speaker is null", "info"), !1; e.speakerEle.pause(), e.speakerEle = null, o("[detectRTC.freeSpeaker] speaker is success", "info") }, setSpeaker(e) { return null === this.speakerEle ? (o("[detectRTC.setSpeaker] speaker is null", "info"), !1) : "" === e ? (o("[detectRTC.setSpeaker] speakerDevice is null", "info"), !1) : (o("[detectRTC.setSpeaker] " + e, "info"), void this.speakerEle.setSinkId(e).then((() => { o("setSpeaker success on:" + e, "info") })).catch((t => { o("setSpeaker filed on:" + e + " " + t, "warn") }))) } }, n = new webrtcDetect, void 0 === (i = function () { return n }.call(t, r, t, e)) || (e.exports = i) }, 879: (e, t, r) => { var i, n = { enabled: !1, samplingPeriod: 100, statPeriod: 6e4, reportPeriod: 6e4, qualityData: [], statBegintime: null, networkStatisticsInterval: null, qualityDataInterval: null, networkStatisticsLists: {}, reportInfo: null, nm_server: "10.226.43.70:28001", joinMeetInfo: {}, meetStartTime: 0, sn: null, loginAuthenticationTime: null, loginDuration: null, getDeviceInfo: async function () { var e = this; return { session: e.getSession(), device: await e.getDevice(), network: e.getNetwork() } }, getAccessInfo: function () { var e = this; return new Date, { userID: webrtcWS.sipNo, userSipURI: webrtcWS.registerTo, regTime: zteUtils.getNowFormatDate(new Date, !0), detectIP: e.detectIP ? e.detectIP : "unKnown", areaCode: e.areaCode ? e.areaCode : "unKnown", areaName: e.areaName ? e.areaName : "unKnown" } }, getEventSubData: function (e, t) { var r = {}, i = 0; if (4 == e) { if ("audio" == t) var n = zteWebrtc.firstAudioPack - webrtcWS.inviteTime; else n = zteWebrtc.firstVidoePack - webrtcWS.inviteTime; r = { meetID: webrtcWS.callNo, type: t, receiveDuration: n }, i = e } else if (40 == e) r.meetID = webrtcWS.callNo, r.eventTime = zteWebrtc.makecallEvent.eventTime, r.eventResult = zteWebrtc.makecallEvent.eventResult, r.eventDuration = zteWebrtc.makecallEvent.eventDuration, r.data = zteWebrtc.makecallEvent.data, zteWebrtc.makecallEvent.data = "", i = zteWebrtc.makecallEvent.callType; else if (50 == e) r.meetID = webrtcWS.callNo, r.eventTime = zteWebrtc.operationInMeeting.eventTime, r.eventResult = zteWebrtc.operationInMeeting.eventResult, r.eventDuration = zteWebrtc.operationInMeeting.eventDuration, r.data = zteWebrtc.operationInMeeting.data, zteWebrtc.operationInMeeting.data = "", i = zteWebrtc.operationInMeeting.operation; else { let t = webrtcPC.mediaParam.audio.direction ? webrtcPC.mediaParam.audio.direction : webrtcConfig.audio.direction, n = webrtcPC.mediaParam.video.direction ? webrtcPC.mediaParam.video.direction : webrtcConfig.video.direction, o = webrtcPC.slidesParam.direction ? webrtcPC.slidesParam.direction : webrtcConfig.slides.direction; if ("sendonly" === t && "sendonly" === n && "sendonly" === o ? r.clientType = 2 : "recvonly" === t && "recvonly" === n && "recvonly" === o ? r.clientType = 1 : "sendrecv" !== t && "sendrecv" !== n && "sendrecv" !== o || (r.clientType = 0), r.meetID = webrtcWS.callNo, r.userSipURI = webrtcWS.sipNo + "@" + webrtcWS.registerTo, r.caller = webrtcWS.sipNo, r.callee = webrtcWS.callNo, 1 == e) { r.callInviteBeginTime = zteUtils.getNowFormatDate(webrtcWS.inviteTime, !0); let t = new Date; this.meetStartTime = t, r.callDirection = 1, r.mediaType = webrtcPC.callType, r.callInviteResult = 0, r.callInviteResultCode = 200, r.hangUpReason = "unknow", r.callInviteEndTime = zteUtils.getNowFormatDate(t, !0), r.callInviteDuration = Math.abs(webrtcWS.inviteTime - t), r.mpsServerIP = zteWebrtc.mediaGetwayAddr, i = e } else if (2 == e) { let t = new Date; r.meetStartTime = zteUtils.getNowFormatDate(this.meetStartTime, !0), r.meetLeaveTime = zteUtils.getNowFormatDate(t, !0), r.meetDuration = t - this.meetStartTime, r.meetLeaveResultCode = "unkonw", i = e } } return { subEventCode: i, subData: r } }, getQualityData: function (e) { var t = this; let r = t.getSessionInfo(); return r.begintime = zteUtils.getNowFormatDate(t.statBegintime, !1), r.endtime = zteUtils.getNowFormatDate(t.statEndtime, !1), t.statBegintime = t.statEndtime.clone(), kpiList = [], t.getSendersReceivers(e).forEach((e => { if (!e.track) return !0; const i = e.track.id; let n = t.getMediaChanInfo(e.track), o = zteUtils.clone(t.networkStatisticsLists[i]), a = o.length; if (0 != a) { t.networkStatisticsLists[i] && (t.networkStatisticsLists[i] = t.networkStatisticsLists[i].splice(a)); var s = t.getNetinfo(e, o); if ("video" === e.track.kind) { let t = e.track.getSettings(); s && s.FPS && (s.FPS = t.frameRate ? t.frameRate : s.SendRecvFps) } if (s && 0 != s.totalPktNum) { let e = Object.assign(n, s); e.meetID = r.meetID, kpiList.push(e) } } })), { session: r, channel: kpiList } }, getSession: function () { return { userID: webrtcWS.sipNo } }, getDevice: async function () { let e = "", t = "", r = "", i = ""; if (zteUtils.isMobile()) { let n = new MobileDetect(window.navigator.userAgent); if (e = n.os(), "iOS" == e) t = n.mobile(), r = n.version(t), i = "Apple"; else if ("AndroidOS" == e) { i = n.phone(), r = n.version("Android"); try { let e = /\((.+?)\)/i.exec(navigator.userAgent)[1].split(";")[2].trim(), r = e.search(/build/i); t = -1 == r ? e : e.slice(0, r - 1) } catch { t = "" } } } else e = zteUtils.getOS(); let n = await this.getIPAddress(), o = { manufacturer: i, modelName: t, appVersion: zteWebrtc.appVersion, appName: zteWebrtc.appName, sdkVersion: zteWebrtc.sdkVersion, osType: e, osVersion: r || "unKnown", ipAddress: n, serverIPAddress: webrtcWS.wssUrl.split("//")[1].split(":")[0] }; return this.getBroswerAndVersion(o), o }, getBroswerAndVersion: function (e) { var t = null, r = navigator.userAgent.toLocaleLowerCase(); r.indexOf("msie") > 0 && (e.modelName = "IE", t = r.match(/msie[\d.]+;/gi)), r.indexOf("firefox") > 0 && (e.modelName = "FireFox", t = r.match(/firefox\/[\d.]+/gi)), r.indexOf("chrome") > 0 && r.indexOf("safari") > 0 && r.indexOf("edg") < 0 && (e.modelName = "Chrome", t = r.match(/chrome\/[\d.]+/gi)), r.indexOf("edg") > 0 && (e.modelName = "Edge", t = r.match(/edg\/[\d.]+/gi)), r.indexOf("opera") > 0 && (e.modelName = "Opera", t = r.match(/opera\/[\d.]+/gi)), r.indexOf("safari") > 0 && r.indexOf("chrome") < 0 && (e.modelName = "Safari", t = r.match(/safari\/[\d.]+/gi)), e.manufacturer = (t + "").replace(/[^0-9.]/gi, "") }, getNetwork: function () { let e = navigator.connection; if (e) { let r = e.type, i = 2; "cellular" == r && (i = 0), "wifi" == r && (i = 1); let n = e.effectiveType, o = 0; "3g" == n && (o = 0), "4g" == n && (o = 1), "5g" == n && (o = 2); var t = { networkType: i, dataAccessMode: o } } else t = { networkType: 255, dataAccessMode: 255 }; return t }, getIPAddress: function () { return new Promise((function (e, t) { let r = { iceServers: [] }; try { var i = new RTCPeerConnection(r); localIps = [], i.onicecandidate = function (e) { if (!e.candidate) return; if (!e.candidate.candidate) return; let t = e.candidate.candidate.split(" ")[4]; localIps.includes(t) || localIps.push(t) }, i.onicegatheringstatechange = function () { switch (i.iceGatheringState) { case "new": case "complete": i.close(), e(localIps[0]) } }, i.createDataChannel(""), i.createOffer().then((e => { i.setLocalDescription(e).then().catch((e => { t(e) })) })).catch((e => { t(e) })) } catch (e) { t(e) } })) }, startGetQualityData: function (e) { if (!this.enabled) return; var t = this; let r = 1e3 * zteUtils.getSeconds() % t.statPeriod, i = t.statPeriod - r; t.qualityData = [], t.statBegintime = new Date, window.setTimeout((function () { t.statEndtime = new Date; let r = t.getQualityData(e); t.qualityData.push(r), t.qualityDataInterval = window.setInterval((function () { t.statEndtime.setSeconds(t.statEndtime.getSeconds() + t.statPeriod / 1e3); let r = t.getQualityData(e); t.qualityData.push(r) }), t.statPeriod) }), i) }, stopGetQualityData: function () { this.qualityDataInterval && window.clearInterval(this.qualityDataInterval), self.qualityData = [] }, getNetinfo: function (e, t) { return "videoSender" === e.label || "videoSubSender" === e.label ? function (e) { let t = { totalRateAvg: 0, totalPktNum: 0, netJiiterAvg: 0, rttAvg: 0, sendRecvFps: 0, FPS: 0 }; const r = e.length; if (r <= 1) return; let i = 0, n = 0, o = 0; for (var a = 0; a < r; a++) { const t = e[a]["outbound-rtp"]; t.jitter && (o++, i += t.jitter, n += t.roundTripTime) } 0 != o && (t.netJiiterAvg = Math.round(i / o * 1e3), t.rttAvg = Math.round(n / o * 1e3)); const s = e[r - 1]["outbound-rtp"], c = e[0]["outbound-rtp"], l = (s.timestamp - c.timestamp) / 1e3; return s.bytesSent && c.bytesSent && (t.totalRateAvg = Math.round((s.bytesSent - c.bytesSent) / l)), t.totalPktNum = s.packetsSent - c.packetsSent, t.resolutionWidth = s.frameWidth, t.resolutionHeight = s.frameHeight, t.sendRecvFps = s.framesPerSecond ? s.framesPerSecond : (s.framesSent - c.framesSent) / l, t.FPS = t.sendRecvFps, t.ssrc = s.ssrc, t }(t) : "audioSender" === e.label ? function (e) { let t = { totalRateAvg: 0, totalPktNum: 0, netJiiterAvg: 0, rttAvg: 0 }; const r = e.length; if (r <= 1) return; let i = 0, n = 0, o = 0; for (var a = 0; a < r; a++) { const t = e[a]["outbound-rtp"]; t.jitter && (o++, i += t.jitter, n += t.roundTripTime) } 0 != o && (t.netJiiterAvg = Math.round(i / o * 1e3), t.rttAvg = Math.round(n / o * 1e3)); const s = e[r - 1]["outbound-rtp"], c = e[0]["outbound-rtp"], l = (e[r - 1]["outbound-rtp"].timestamp - e[0]["outbound-rtp"].timestamp) / 1e3; return s.bytesSent && c.bytesSent && (t.totalRateAvg = Math.round((s.bytesSent - c.bytesSent) / l)), t.totalPktNum = s.packetsSent - c.packetsSent, t.ssrc = s.ssrc, t }(t) : "videoReceiver" === e.label || "videoSubReceiver" === e.label ? function (e) { let t = { totalRateAvg: 0, totalPktNum: 0, netLostPktRatioAvg: 0, sendRecvFps: 0, frozenTime: 0, frozenRate: 0, frozenNum: 0, FPS: 0, realLostPktNum: 0, realLostPktRatioAvg: 0 }; const r = e.length; if (r <= 1) return; let i = 0, n = 0; for (var o = 1; o < r; o++)if (e[o]["inbound-rtp"].framesDecoded - e[o - 1]["inbound-rtp"].framesDecoded == 0) { let t = e[o]["inbound-rtp"].timestamp - e[o - 1]["inbound-rtp"].timestamp; t > 600 && (i = t, n++) } const a = e[r - 1]["inbound-rtp"], s = e[0]["inbound-rtp"], c = (e[r - 1]["inbound-rtp"].timestamp - e[0]["inbound-rtp"].timestamp) / 1e3; a.bytesReceived && s.bytesReceived && (t.totalRateAvg = Math.round((a.bytesReceived - s.bytesReceived) / c)), t.totalPktNum = a.packetsReceived - s.packetsReceived; let l = a.packetsLost - s.packetsLost; return 0 != t.totalPktNum && (t.netLostPktRatioAvg = Math.round(l / t.totalPktNum * 100)), t.realLostPktNum = l, t.realLostPktRatioAvg = t.netLostPktRatioAvg, t.resolutionWidth = a.frameWidth, t.resolutionHeight = a.frameHeight, t.sendRecvFps = a.framesPerSecond ? a.framesPerSecond : (a.framesReceived - s.framesReceived) / c, t.FPS = t.sendRecvFps, t.frozenTime = i, t.frozenRate = Math.round(i / 1e3 / c * 100), t.ssrc = a.ssrc, t.frozenNum = n, t }(t) : "audioReceiver" === e.label ? function (e) { let t = { totalRateAvg: 0, totalPktNum: 0, netLostPktRatioAvg: 0, frozenTime: 0, frozenRate: 0, frozenNum: 0, realLostPktNum: 0, realLostPktRatioAvg: 0 }; const r = e.length; let i = 0, n = 0; for (var o = 1; o < r; o++)if (e[o]["inbound-rtp"].totalSamplesReceived - e[o - 1]["inbound-rtp"].totalSamplesReceived == 0) { let t = e[o]["inbound-rtp"].timestamp - e[o - 1]["inbound-rtp"].timestamp; t > 200 && (n++, i = t) } const a = e[r - 1]["inbound-rtp"], s = e[0]["inbound-rtp"], c = (e[r - 1]["inbound-rtp"].timestamp - e[0]["inbound-rtp"].timestamp) / 1e3; a.bytesReceived && s.bytesReceived && (t.totalRateAvg = Math.round((a.bytesReceived - s.bytesReceived) / c)), t.totalPktNum = a.packetsReceived - s.packetsReceived; let l = a.packetsLost - s.packetsLost; return 0 != t.totalPktNum && (t.netLostPktRatioAvg = Math.round(l / t.totalPktNum * 100)), t.realLostPktNum = l, t.realLostPktRatioAvg = t.netLostPktRatioAvg, t.frozenTime = i, t.frozenRate = Math.round(i / 1e3 / c * 100), t.ssrc = a.ssrc, t.frozenNum = n, t }(t) : void 0 }, startGetNetworkStatistics: function (e) { if (this.enabled) { var t = this; t.initNetworkStatisticsLists(e), t.getNetworkStatistics(e), t.networkStatisticsInterval = window.setInterval((function () { t.getNetworkStatistics(e) }), t.samplingPeriod) } }, stopGetNetworkStatistics: function () { this.networkStatisticsInterval && window.clearInterval(this.networkStatisticsInterval), this.networkStatisticsLists = {} }, initNetworkStatisticsLists: function (e) { var t = this; t.getSendersReceivers(e).forEach((e => { if (!e.track) return !0; const r = e.track.id; t.networkStatisticsLists[r] = [] })) }, getSendersReceivers: function (e) { let t = e.getSenders(), r = e.getReceivers(); return zteUtils.arrayConcat_pc(t, r) }, getNetworkStatistics: async function (e) { var t = this; e instanceof RTCPeerConnection && t.getSendersReceivers(e).forEach((e => { e.getStats().then((r => { if (r.forEach((t => { 0 == zteWebrtc.firstAudioPack && "inbound-rtp" === t.type && "audio" === t.kind && (zteWebrtc.firstAudioPack = (new Date).getTime(), n.event(4, "audio")), 0 == zteWebrtc.firstVidoePack && "inbound-rtp" === t.type && "video" === t.kind && (zteWebrtc.firstVidoePack = (new Date).getTime(), n.event(4, "video")), e[t.type] = t })), e && e.track && e.track.id && (e["inbound-rtp"] || e["outbound-rtp"])) { let r = JSON.parse(JSON.stringify(e)); r.track = JSON.parse(JSON.stringify(e.track)), t.networkStatisticsLists[e.track.id] || (t.networkStatisticsLists[e.track.id] = []), t.networkStatisticsLists[e.track.id].push(r) } })) })) }, getMediaChanInfo: function (e) { let t = {}; return "audio" === e.kind ? (t.channelType = 0, t.codeFormat = zteWebrtc.audioCodeFormate) : "video" === e.kind && (t.channelType = 1, t.codeFormat = zteWebrtc.videoCodeFormate), t.channelId = e.channelId, t.svctype = e.svctype, t.channelDirection = e.channelDirection, t }, getSessionInfo: function () { let e = {}; return e.meetID = webrtcWS.callNo, e.userID = webrtcWS.sipNo, e }, bootmessage: async function () { if (!this.enabled) return; let e = {}; e.sn = this.sn; let t = await this.getDeviceInfo(); e.terminalType = 3, e.vendor = t.device.manufacturer, e.model = t.device.modelName, e.eventCode = 1, e.terminalName = this.sn, this.reportInfo = { sn: e.sn, vendor: e.vendor, model: e.model, terminalType: e.terminalType, terminalName: e.sn }, e.clientTime = zteUtils.getNowFormatDate(new Date, !1); let r = this.getAccessInfo(); e.data = { appName: t.device.appName, appVersion: t.device.appVersion, sdkVersion: t.device.sdkVersion, osType: t.device.osType, osVersion: t.device.osVersion, ipAddress: t.device.ipAddress, serverIPAddress: t.device.serverIPAddress, userSipURI: r.userID + "@" + r.userSipURI, regTime: r.regTime, detectIP: r.detectIP, areaCode: r.areaCode, areaName: r.areaName, loginResult: 1, loginAuthenticationTime: this.loginAuthenticationTime ? zteUtils.getNowFormatDate(this.loginAuthenticationTime, !0) : "YYYY-MM-DDThh:mm:ss.xxxZ", loginDuration: this.loginAuthenticationTime ? (new Date - this.loginAuthenticationTime).toString() : "0" } }, event: function (e, t) { if (!this.enabled) return; let r = {}; r.sn = this.reportInfo.sn, r.vendor = this.reportInfo.vendor, r.model = this.reportInfo.model, r.terminalType = this.reportInfo.terminalType, r.terminalName = this.reportInfo.terminalName, r.eventCode = 4, r.clientTime = zteUtils.getNowFormatDate(new Date, !1), r.data = {}, r.data = this.getEventSubData(e, t) }, periodmessage: function (e) { var t = this; let r = {}; r.sn = this.reportInfo.sn, r.vendor = this.reportInfo.vendor, r.model = this.reportInfo.model, r.terminalType = this.reportInfo.terminalType, r.terminalName = this.reportInfo.terminalName, r.eventCode = 2, r.clientTime = zteUtils.getNowFormatDate(new Date, !1), r.datas = [], e.forEach((function (e) { let i = { subEventCode: 1, sampleStartTime: e.session.begintime, sampleEndTime: e.session.endtime, subData: { systemCPU: 255, appCPU: 255, systemMemory: null, appMemory: null, systemIdleMemory: null } }; r.datas.push(i); let n = { subEventCode: 2, sampleStartTime: e.session.begintime, sampleEndTime: e.session.endtime, subData: t.getNetwork() }; r.datas.push(n); let o = { subEventCode: 4, sampleStartTime: e.session.begintime, sampleEndTime: e.session.endtime, subData: { channels: e.channel } }; r.datas.push(o) })) }, startPeriodmessage: function () { if (this.enabled) { var e = this; e.periodmessageInterval = window.setInterval((function () { let t = zteUtils.clone(e.qualityData), r = t.length; e.qualityData = e.qualityData.splice(r), e.periodmessage(t) }), e.reportPeriod) } }, stopPeriodmessage: function () { this.periodmessageInterval && (window.clearInterval(this.periodmessageInterval), zteWebrtc.log("[webrtcPFM] stop networkStatisticsInterval", "info")), this.qualityData = [] } }; void 0 === (i = function () { return n }.call(t, r, t, e)) || (e.exports = i) }, 182: (e, t, r) => { var n; function o(e) { this.module = e } if (o.prototype.log = function (e) { console.log("[" + this.currentTimeStr() + "][" + this.module + "]" + e) }, o.prototype.logError = function (e) { console.error("[" + this.currentTimeStr() + "][" + this.module + "] " + e) }, o.prototype.logInfo = function (e) { console.info("[" + this.currentTimeStr() + "][" + this.module + "] " + e) }, o.prototype.logDebug = function (e) { console.debug("[" + this.currentTimeStr() + "][" + this.module + "] " + e) }, o.prototype.logWarn = function (e) { console.warn("[" + this.currentTimeStr() + "][" + this.module + "] " + e) }, o.prototype.currentTimeStr = function () { var e = new Date(Date.now()); return e.getFullYear() + "-" + (e.getMonth() + 1) + "-" + e.getDate() + " " + e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds() + ":" + e.getMilliseconds() }, null == a) var a = {}; a.DECIMAL_SEP = ".", a.DATE_FORMAT = "yyyy-MM-dd", a.alert = function (e) { alert(e) }, a.strTrim = function (e) { return e.replace(/^\s+/, "").replace(/\s+$/, "") }, a.isString = function (e) { return "string" == typeof e }, a.isInt = function (e) { return new RegExp("^[-+]{0,1}[0-9]*$").test(e) }, a.isPosInt = function (e) { return /^\d+$/.test(e) }, a.isNegInt = function (e) { return /^-\d+$/.test(e) }, a.isPostInteger = function (e) { return /^[1-9]\d*$/.test(e) }, a.specialPattern0 = new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>/?~@#&*|{}']"), a.specialPattern1 = new RegExp("[~|^']"), a.isHasSpecialChar = function (e) { return a.specialPattern1.test(e) }, a.isDouble = function (e) { var t = a.DECIMAL_SEP; return new RegExp("^[-+]{0,1}[0-9]*[" + t + "]{0,1}[0-9]*$").test(e) }, a.isEmpty = function (e) { return !(a.isString(e) && e.length > 0) }, a.isEmail = function (e) { if (!a.isString(e)) return a.alert("Not String"), !1; var t = new RegExp("^(([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}){0,1}$"), r = new RegExp("^.*<(([0-9a-zA-Z]+[-._+&])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}){0,1}>$"); return t.test(e) || r.test(e) }, a.isPhone = function (e) { return /(^[0-9]{7,21}$)/.test(e) }, a.isTime = function (e) { var t = e.match(/^(\d{1,2})(:)?(\d{1,2})\2(\d{1,2})$/); return null != t && !(t[1] > 24 || t[3] > 60 || t[4] > 60) }, a.isDateTime = function (e) { var t = e.match(/^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/); if (null == t) return !1; var r = new Date(t[1], t[3] - 1, t[4], t[5], t[6], t[7]); return r.getFullYear() == t[1] && r.getMonth() + 1 == t[3] && r.getDate() == t[4] && r.getHours() == t[5] && r.getMinutes() == t[6] && r.getSeconds() == t[7] }, a.isDate = function (e) { if (a.isEmpty(e)) return !1; var t = a.DATE_FORMAT; return ddReg = new RegExp("dd"), MMReg = new RegExp("MM"), yyyyReg = new RegExp("yyyy"), ddReg.test(t) && MMReg.test(t) && yyyyReg.test(t) ? (ddStart = t.indexOf("dd"), MMStart = t.indexOf("MM"), yyyyStart = t.indexOf("yyyy"), strReg = t.replace("dd", "[0-9]{2}").replace("MM", "[0-9]{2}").replace("yyyy", "[0-9]{4}"), reg = new RegExp("^" + strReg + "$"), !!reg.test(e) && (dd = e.substring(ddStart, ddStart + 2), MM = e.substring(MMStart, MMStart + 2), yyyy = e.substring(yyyyStart, yyyyStart + 4), !!a.checkddMMyyyy(dd, MM, yyyy))) : (a.alert("DEBUG: locale format " + t + " not supported"), !1) }, a.checkddMMyyyy = function (e, t, r) { return retVal = !0, (e < 1 || e > 31 || t < 1 || t > 12 || 31 == e && (2 == t || 4 == t || 6 == t || 9 == t || 11 == t) || e > 29 && 2 == t || 29 == e && 2 == t && (r % 4 > 0 || r % 4 == 0 && r % 100 == 0 && r % 400 > 0)) && (retVal = !1), retVal }, a.replaceAll = function (e, t, r) { for (; e.indexOf(t) > -1;)e = e.replace(t, r); return e }, a.leftPadZero = function (e) { return e < 10 ? "0" + e : "" + e }, a.shortTimeInc = function (e, t) { var r = e.split(":"), i = parseInt(r[2], 10), n = parseInt(r[1], 10), o = parseInt(r[0], 10); return (i += t) > 59 && (i = 0, n += 1), n > 59 && (n = 0, o += 1), this.leftPadZero(o) + ":" + this.leftPadZero(n) + ":" + this.leftPadZero(i) }, a.getMilliSecondsDiff = function (e, t) { return null == e || null == t ? 0 : t.getTime() - e.getTime() }, a.getDiffTime = function (e, t) { var r = a.getMilliSecondsDiff(e, t); if (r > 0) { r = Math.floor(r / 1e3); var i = Math.floor(r / 3600) + ""; i = 1 == i.length ? "0" + i : i; var n = Math.floor(r % 3600 / 60) + "", o = r % 60 + ""; return i + ":" + (n = 1 == n.length ? "0" + n : n) + ":" + (1 == o.length ? "0" + o : o) } return "00:00:00" }, a.dateToString = function (e) { if (null == e) return ""; var t = new Array; t.push(e.getFullYear()), t.push("-"); var r = e.getMonth() + 1; r < 10 && t.push("0"), t.push(r), t.push("-"); var i = e.getDate(); i < 10 && t.push("0"), t.push(i), t.push(" "); var n = e.getHours(); n < 10 && t.push("0"), t.push(n), t.push(":"); var o = e.getMinutes(); o < 10 && t.push("0"), t.push(o), t.push(":"); var a = e.getSeconds(); return a < 10 && t.push("0"), t.push(a), t.join("") }, a.dateFormatStr = function (e, t) { var r = { "M+": e.getMonth() + 1, "d+": e.getDate(), "h+": e.getHours(), "m+": e.getMinutes(), "s+": e.getSeconds(), "q+": Math.floor((e.getMonth() + 3) / 3), S: e.getMilliseconds() }; for (var i in /(y+)/.test(t) && (t = t.replace(RegExp.$1, (e.getFullYear() + "").substr(4 - RegExp.$1.length))), r) new RegExp("(" + i + ")").test(t) && (t = t.replace(RegExp.$1, 1 == RegExp.$1.length ? r[i] : ("00" + r[i]).substr(("" + r[i]).length))); return t }, a.stringToDate = function (e) { var t = null; return e && ((t = new Date).setFullYear(parseInt(e.substring(0, 4), 10), parseInt(e.substring(5, 7), 10) - 1, parseInt(e.substring(8, 10), 10)), t.setHours(parseInt(e.substring(11, 13), 10), parseInt(e.substring(14, 16), 10), parseInt(e.substring(17, 19), 10))), t }, a.parseURL = function (e) { var t = document.createElement("a"); return t.href = e, { source: e, protocol: t.protocol.replace(":", ""), host: t.hostname, port: t.port, query: t.search, params: function () { for (var e, r = {}, i = t.search.replace(/^\?/, "").split("&"), n = i.length, o = 0; o < n; o++)i[o] && (r[(e = i[o].split("="))[0]] = e[1]); return r }(), file: (t.pathname.match(/\/([^\/?#]+)$/i) || [null, ""])[1], hash: t.hash.replace("#", ""), path: t.pathname.replace(/^([^\/])/, "/$1"), relative: (t.href.match(/tps?:\/\/[^\/]+(.+)/) || [null, ""])[1], segments: t.pathname.replace(/^\//, "").split("/") } }, a.replaceUrlObjParams = function (e, t) { for (var r in t) { var i = !1; for (var n in e.params) if (r.toLowerCase() == n.toLowerCase()) { e.params[n] = t[r], i = !0; break } i || (e.params[r] = t[r]) } var o = e.protocol + "://" + e.host + ":" + e.port + e.path + "?"; for (var a in e.params) o += a + "=" + e.params[a] + "&"; return "&" == o.substr(o.length - 1) && (o = o.substr(0, o.length - 1)), "" != e.hash && (o += "#" + e.hash), o }, a.replaceUrlParams = function (e, t) { var r = a.parseURL(e); for (var i in t) { var n = !1; for (var o in r.params) if (i == o) { r.params[o] = t[i], n = !0; break } n || (r.params[i] = t[i]) } var s = ""; for (var c in s = null != r.protocol && "" != r.protocol && null != r.host && "" != r.host && null != r.port && "" != r.port ? r.protocol + "://" + r.host + ":" + r.port + r.path + "?" : 0 == e.indexOf("/") ? r.path + "?" : "./" + r.path + "?", r.params) s += c + "=" + (null == r.params[c] ? "" : r.params[c]) + "&"; return "&" == s.substr(s.length - 1) && (s = s.substr(0, s.length - 1)), "" != r.hash && (s += "#" + r.hash), s }, a.isNullString = function (e) { return null == e || null == e || "" == e }, a.getSelText = function (e) { var t = ""; return $.each($(e)[0].options, (function (e, r) { if (r.selected) return t = r.text, !1 })), t }, a._decodeParam = function (e) { var t, r, i = {}; if (!e) return i; for (var n, o = 0, a = e.indexOf("=", o); a > -1;) { if ("us" === (t = e.substring(o, a).toLowerCase())) { r = e.substring(a + 1), i[t] = r; break } (n = e.indexOf(";", a)) > -1 ? (o = n + 1, r = e.substring(a + 1, n)) : (o = e.length, r = e.substring(a + 1)), i[t] = r, a = e.indexOf("=", o) } return i }, a.isOver9 = function () { var e = navigator.userAgent, t = e.indexOf("compatible") > -1 && e.indexOf("MSIE") > -1, r = e.indexOf("Edge") > -1 && !t, i = e.indexOf("Trident") > -1 && e.indexOf("rv:11.0") > -1; return t ? (new RegExp("MSIE (\\d+\\.\\d+);").test(e), !(parseFloat(RegExp.$1) <= 9) && void 0) : !!r || !!i }, a.randomMac = function () { return [82..toString(16), 84..toString(16), (0).toString(16), Math.floor(255 * Math.random()).toString(16), Math.floor(255 * Math.random()).toString(16), Math.floor(255 * Math.random()).toString(16)].join(":") }, a.generateUUID = function () { var e = (new Date).getTime(); return window.performance && "function" == typeof window.performance.now && (e += performance.now()), "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { var r = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" == t ? r : 3 & r | 8).toString(16) })) }, a.getIosVersion = function () { var e = "", t = navigator.userAgent.toLowerCase().match(/cpu iphone os (.*?) like mac os/); return t && (e = t[1].replace(/_/g, ".")), e }, a.getTime = function () { var e = "", t = new Date, r = t.getHours(), i = t.getMinutes(), n = t.getSeconds(), o = t.getMilliseconds(); return r < 10 && (e += "0"), e += r + ":", i < 10 && (e += "0"), e += i + ":", n < 10 && (e += "0"), e += n + ".", o < 10 && (e += "00"), o > 10 && o < 100 && (e += "0"), e + o }, a.getSeconds = function () { var e = new Date; return 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds() }, a.createHexRandom = function (e) { var t = ""; for (i = 0; i < e; i++) { var r = Math.ceil(15 * Math.random()); if (r > 9) switch (r) { case 10: t += "a"; break; case 11: t += "b"; break; case 12: t += "c"; break; case 13: t += "d"; break; case 14: t += "e"; break; case 15: t += "f" } else t += r } return t }, a.arrayConcat_pc = function (e, t) { for (var r = e.concat(), i = 0; i < t.length; i++)-1 === r.indexOf(t[i]) && r.push(t[i]); return r }, a.clone = function (e) { function t() { } return t.prototype = e, new t }, a.isIPhone = function () { return "iphone os" == navigator.userAgent.toLowerCase().match(/iphone os/i) }, a.isMobile = function () { var e = navigator.userAgent.toLowerCase(), t = "ipad" == e.match(/ipad/i), r = "iphone os" == e.match(/iphone os/i), i = "midp" == e.match(/midp/i), n = "rv:1.2.3.4" == e.match(/rv:1.2.3.4/i), o = "ucweb" == e.match(/ucweb/i), a = "android" == e.match(/android/i), s = "windows ce" == e.match(/windows ce/i), c = "windows mobile" == e.match(/windows mobile/i), l = "micromessenger" == e.match(/MicroMessenger/i); return !!(t || r || i || n || o || a || s || c || l) }, a.getOS = function () { var e = navigator.userAgent, t = "Win32" == navigator.platform || "Windows" == navigator.platform, r = "Mac68K" == navigator.platform || "MacPPC" == navigator.platform || "Macintosh" == navigator.platform || "MacIntel" == navigator.platform; if (r) return "Mac"; if ("X11" == navigator.platform && !t && !r) return "Unix"; if (String(navigator.platform).indexOf("Linux") > -1) return "Linux"; if (t) { if (e.indexOf("Windows NT 5.0") > -1 || e.indexOf("Windows 2000") > -1) return "Win2000"; if (e.indexOf("Windows NT 5.1") > -1 || e.indexOf("Windows XP") > -1) return "WinXP"; if (e.indexOf("Windows NT 5.2") > -1 || e.indexOf("Windows 2003") > -1) return "Win2003"; if (e.indexOf("Windows NT 6.0") > -1 || e.indexOf("Windows Vista") > -1) return "WinVista"; if (e.indexOf("Windows NT 6.1") > -1 || e.indexOf("Windows 7") > -1) return "Win7"; if (e.indexOf("Windows NT 10") > -1 || e.indexOf("Windows 10") > -1) return "Win10" } return "other" }, a.toPercent = function (e) { return Number(100 * e).toFixed(1) + "%" }, a.getNowFormatDate = function (e, t) { t = t || !1; var r = (e = e || new Date).toISOString(); return t ? r : r.substring(0, 19) + "Z" }, a.getDuration = function (e) { var t = new Date(e), r = new Date; return parseInt((r.getTime() - t.getTime()) / 1e3) }, a.formatDate = function (e) { var t = e.getMonth() + 1, r = e.getDate(); return t >= 1 && t <= 9 && (t = "0" + t), r >= 0 && r <= 9 && (r = "0" + r), e.getFullYear() + "-" + t + "-" + r + "T" + e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds() }, Date.prototype.clone = function () { return new Date(this.valueOf()) }, a.BASE64 = function () { _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", this.encode = function (e) { var t, r, i, n, o, a, s, c = "", l = 0; for (e = _utf8_encode(e); l < e.length;)n = (t = e.charCodeAt(l++)) >> 2, o = (3 & t) << 4 | (r = e.charCodeAt(l++)) >> 4, a = (15 & r) << 2 | (i = e.charCodeAt(l++)) >> 6, s = 63 & i, isNaN(r) ? a = s = 64 : isNaN(i) && (s = 64), c = c + _keyStr.charAt(n) + _keyStr.charAt(o) + _keyStr.charAt(a) + _keyStr.charAt(s); return c }, this.decode = function (e) { var t, r, i, n, o, a, s = "", c = 0; for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); c < e.length;)t = _keyStr.indexOf(e.charAt(c++)) << 2 | (n = _keyStr.indexOf(e.charAt(c++))) >> 4, r = (15 & n) << 4 | (o = _keyStr.indexOf(e.charAt(c++))) >> 2, i = (3 & o) << 6 | (a = _keyStr.indexOf(e.charAt(c++))), s += String.fromCharCode(t), 64 != o && (s += String.fromCharCode(r)), 64 != a && (s += String.fromCharCode(i)); return _utf8_decode(s) }, _utf8_encode = function (e) { e = e.replace(/\r\n/g, "\n"); for (var t = "", r = 0; r < e.length; r++) { var i = e.charCodeAt(r); i < 128 ? t += String.fromCharCode(i) : i > 127 && i < 2048 ? (t += String.fromCharCode(i >> 6 | 192), t += String.fromCharCode(63 & i | 128)) : (t += String.fromCharCode(i >> 12 | 224), t += String.fromCharCode(i >> 6 & 63 | 128), t += String.fromCharCode(63 & i | 128)) } return t }, _utf8_decode = function (e) { for (var t = "", r = 0, i = 0, n = 0, o = 0; r < e.length;)(i = e.charCodeAt(r)) < 128 ? (t += String.fromCharCode(i), r++) : i > 191 && i < 224 ? (n = e.charCodeAt(r + 1), t += String.fromCharCode((31 & i) << 6 | 63 & n), r += 2) : (n = e.charCodeAt(r + 1), o = e.charCodeAt(r + 2), t += String.fromCharCode((15 & i) << 12 | (63 & n) << 6 | 63 & o), r += 3); return t } }, a.checkIP = function (e) { return flag_ip = /^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$/.test(e), !!flag_ip }, a.parseSDP = function (e) { e.indexOf("PCMA") > 0 && (zteWebrtc.audioCodeFormate = "G711.A"), e.indexOf("PCMU") > 0 && (zteWebrtc.audioCodeFormate = "G711.U"), e.indexOf("H264") > 0 && (zteWebrtc.videoCodeFormate = "H.264"), e.indexOf("H265") > 0 && (zteWebrtc.videoCodeFormate = "H.265"); let t = e.indexOf("a=candidate"), r = e.indexOf("host generation"), i = e.substring(t, r); zteWebrtc.mediaGetwayAddr = i.split(" ")[4] }, a.strToBinary = function (e) { if (!e) return console.log("your str is null, please checkout str"), null; var t = [], r = e.split(""); for (let e = 0; e < r.length; e++) { let i = parseInt(r[e].charCodeAt()); t.push(i) } return t }, a.binaryToStr = function (e) { if (!e) return console.log("your binary is null, please checkout binary"), null; var t = ""; for (let r = 0; r < e.length; r++)t += String.fromCharCode(e[r]); return t }, a.arrayConcat = function (e, t, r) { var i = e.length, n = t.length; if (0 != i && 0 != n) { if ("Uint8Array" === r) var o = new Uint8Array(i + n); else if ("Uint16Array" === r) o = new Uint16Array(i + n); else { if ("Uint32Array" !== r) return void console.log("Unsupported array type"); o = new Uint32Array(i + n) } for (let t = 0; t < i; t++)o[t] = e[t]; for (let e = 0; e < n; e++)o[e + i] = t[e]; return o } console.log("you need not concat") }, a.interceptArray = function (e, t, r, i) { if (0 != e.length) if (r > e.length) console.log("the index of you want to intercept is out of range"); else { if (!(t < 0)) { if ("Uint8Array" === i) var n = new Uint8Array(r - t); else if ("Uint16Array" === i) n = new Uint16Array(r - t); else { if ("Uint32Array" !== i) return void console.log("Unsupported array type"); n = new Uint32Array(r - t) } for (let i = 0; i < r - t; i++)n[i] = e[i + r]; return n } console.log("the index of formIndex can not less than 0") } else console.log("the length of source array is 0, you can not intercept the array") }, a.getSsrc = function () { var e = 0; for (let t = 0; t < 32; t++)e = Math.round(Math.random()) + 2 * e; return e }, a.Uint8ArrayToString = function (e) { for (var t = "", r = 0; r < e.length; r++)t += String.fromCharCode(e[r]); return t }, a.stringToUint8Array = function (e) { if (!e) return new Uint8Array; for (var t = [], r = 0, i = e.length; r < i; r++)t.push(e.charCodeAt(r)); return new Uint8Array(t) }, a.getAddressType = function (e) { if (!(e.indexOf(":") > -1)) return !1; { let i = e.lastIndexOf(":"); var t = e.substring(0, i); t.indexOf("[") > -1 && t.replace("[", ""), t.indexOf("]") > -1 && t.replace("]", ""); var r = e.substring(i, e.length) } let i = null; return !!t && (i = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/.test(t) ? t + r : /^([\da-fA-F]{1,4}:){6}((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^::([\da-fA-F]{1,4}:){0,4}((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^([\da-fA-F]{1,4}:):([\da-fA-F]{1,4}:){0,3}((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^([\da-fA-F]{1,4}:){2}:([\da-fA-F]{1,4}:){0,2}((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^([\da-fA-F]{1,4}:){3}:([\da-fA-F]{1,4}:){0,1}((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^([\da-fA-F]{1,4}:){4}:((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$|^([\da-fA-F]{1,4}:){7}[\da-fA-F]{1,4}$|^:((:[\da-fA-F]{1,4}){1,6}|:)$|^[\da-fA-F]{1,4}:((:[\da-fA-F]{1,4}){1,5}|:)$|^([\da-fA-F]{1,4}:){2}((:[\da-fA-F]{1,4}){1,4}|:)$|^([\da-fA-F]{1,4}:){3}((:[\da-fA-F]{1,4}){1,3}|:)$|^([\da-fA-F]{1,4}:){4}((:[\da-fA-F]{1,4}){1,2}|:)$|^([\da-fA-F]{1,4}:){5}:([\da-fA-F]{1,4})?$|^([\da-fA-F]{1,4}:){6}:$/.test(t) ? "[" + t + "]" + r : t + r, i) }, void 0 === (n = function () { return a }.call(t, r, t, e)) || (e.exports = n) }, 653: (e, t, r) => { var i, n = { instanceId: Math.ceil(1e4 * Math.random()), version: "1.01.01.x", appName: "webRTC SDK", appVersion: "ZXIVS-SRTNV1.01.01.x", sdkVersion: "ZXIVS-SRTNV2.23.11", localTag: null, remoteTag: null, subTag: null, sipNo: null, devices: { audioinputArr: [], audiooutputArr: [], videoinputArr: [] }, devicesStr: "", constraints: null, headers: {}, videoFlag: !0, constraintsForCameraChoose: null, localVideo: null, cameraToSubFlag: !1, localSDP: null, remoteSDP: null, videoCodeFormate: null, audioCodeFormate: null, mediaGetwayAddr: null, firstAudioPack: 0, firstVidoePack: 0, jsonLoadOk: !1, baseUrl: "", localVideoOpenFlag: !0, currentVideoInputDeviceID: null, currentAudioInputDeviceID: null, currentAudioOutputDeviceID: null, currentSlideVideoInputDeviceID: null, audioMuted: !1, callStatus: 0, floorTokenHoldStatus: 0, makecallEvent: { callType: 0, eventTime: "", eventResult: "", eventDuration: 0, data: "" }, operationInMeeting: { operation: 0, eventTime: "", eventResult: "", eventDuration: 0, data: "" }, sendSlidesFlag: !1, HPCodeAbility: null, streamType: "single", registerState: 0, seminarRole: "guest", signalArray: [], CsID: null, onUseDevice: { camera: { id: "", label: "" }, microPhone: { id: "", label: "" }, speaker: { id: "", label: "" } }, updateOnUseDevice: function (e, t = !1, r = !1) { var i = this; if (t || r) return t && (i.onUseDevice.microPhone.label = "", i.onUseDevice.microPhone.id = "", n.publishEvent("inputAudioChanged", ["", ""])), void (r && (i.onUseDevice.camera.label = "", i.onUseDevice.camera.id = "", n.publishEvent("inputVideoChanged", ["", ""]))); (i.devices.audioinputArr.length <= 0 || i.devices.videoinputArr.length <= 0) && i.getDevices(); let o = e.getAudioTracks(), a = e.getVideoTracks(); if (o && o[0] && i.devices.audioinputArr.length > 0) { console.log("audio[0].label:", o[0].label); for (let e in i.devices.audioinputArr) if (i.devices.audioinputArr[e].label == o[0].label) { i.onUseDevice.microPhone.label = o[0].label, i.onUseDevice.microPhone.id = i.devices.audioinputArr[e].deviceId, console.log("updateOnUseDevice audio:", i.onUseDevice.microPhone), n.publishEvent("inputAudioChanged", [i.onUseDevice.microPhone.id, i.onUseDevice.microPhone.label]); break } } else n.log("[webrtcCore] updateOnUseDevice, audio is null"); if (a && a[0] && i.devices.videoinputArr.length) { console.log("video[0].label:", a[0].label); for (let e in i.devices.videoinputArr) if (i.devices.videoinputArr[e].label == a[0].label) { i.onUseDevice.camera.label = a[0].label, i.onUseDevice.camera.id = i.devices.videoinputArr[e].deviceId, console.log("updateOnUseDevice video:", i.onUseDevice.camera), n.publishEvent("inputVideoChanged", [i.onUseDevice.camera.id, i.onUseDevice.camera.label]); break } } else n.log("[webrtcCore] updateOnUseDevice, video is null"); console.log("[webrtcCore] updateOnUseDevice, video/audio:", i.onUseDevice.camera, i.onUseDevice.microPhone) }, getOnUseDevice: function (e = 0) { return 0 == e ? this.onUseDevice.camera : 1 == e ? this.onUseDevice.microPhone : 2 == e ? this.onUseDevice.speaker : (n.log("[webrtcCore] getOnUseDevice, type is not 0 or 1"), -1) }, getVersion: function () { var e = n.sdkVersion; return 0 == e.length ? "failed" : e }, updateUsersig: function (e) { if (!e) return n.log("[webrtcCore] usersig is null", "warn"), 2; let t = new zteUtils.BASE64, [r, i] = e.split("."), o = t.decode(r), a = JSON.parse(o), s = a.userid ? a.appid + "," + a.userid : a.appid, c = "sdk-hmac signature=" + i; return n.headers = function () { return { "Content-Type": "application/json;charset=utf-8", TransactionID: zteUtils.generateUUID(), "x-timestamp": Math.round(new Date / 1e3), "x-app-user-id": s, "x-sdk-userinfo": r, Authorization: c } }, c.length > 19 ? (n.log("[webrtcCore] updateUsersig success:" + c, "info"), 0) : (n.log("[webrtcCore] updateUsersig failed: authorization is null", "warn"), 1) }, register: function (e, t, r, i, o, a, s, c = "single") { if (n.streamType = c, "string" != typeof e || "" === e) return void n.log("[register method] the param of sipNo is incorrect, please check sipNo, the sipNo you have delivered is:" + e); if ("string" != typeof t || "" === t) return void n.log("[register method] the param of address is incorrect, please check address, the address you have delivered is:" + t); if ("number" != typeof r || 0 === r) return void n.log("[register method] the param of heartbeatTime is incorrect, please check heartbeatTime, the heartbeatTime you have delivered is:" + r); if ("string" != typeof i) return void n.log("[register method] the param of sipPwd is incorrect, please check sipPwd, the sipPwd you have delivered is:" + i); if ("string" != typeof o || "" === o) return void n.log("[register method] the param of sipUrl is incorrect, please check sipUrl, the sipUrl you have delivered is:" + o); if ("number" != typeof a || 0 === a) return void n.log("[register method] the param of connectTimeout is incorrect, please check connectTimeout, the connectTimeout you have delivered is:" + a); if (1 == n.registerState) return void (webrtcWS.sipNo == e ? (n.log("[webrtcCore] register failed: user has registered", "error"), n.publishEvent("onRegister", [101, "websocket connect fail, user has registered"])) : (n.log("[webrtcCore] register failed: a user has registered", "error"), n.publishEvent("onRegister", [102, "websocket connect fail, a user has registered"]))); if (2 == n.registerState) return n.log("[webrtcCore] register failed: Registering", "error"), void n.publishEvent("onRegister", [103, "websocket connect fail, Registering"]); if (3 == n.registerState) return n.log("[webrtcCore] register failed: unRegistering", "error"), void n.publishEvent("onRegister", [104, "websocket connect fail, unRegistering"]); n.registerState = 2, s && (s.appName && (this.appName = s.appName), s.appVersion && (this.appVersion = s.appVersion)), this.sipNo = e, webrtcPFM.sn = e, n.log("[zteWebrtc]: {method: register, param: " + JSON.stringify([e, i, t, r, o, a, s]) + "}", "info"); let l = n.constructAndDealSignalNode("register", "single_register_beforeWebsocketConnect", "single_register_afterWebsocketConnect", "start"); 0 == l ? webrtcWS.init("", e, i, t, r, o, a, s) : n.log("the result of signal deal is " + l) }, registerFailedDeal: function (e) { n.log("register failed, the errorCode is" + e, "error"), n.registerState = 0 }, makecallFailedDeal: function (e) { n.log("makecall failed, the errorCode is" + e, "error"), n.callStatus = 0, n.makecallEvent.data = "the errorCode is " + e, n.eventReport(1, 40) }, unRegister: function () { if (1 != n.registerState) return n.log("[zteWebrtc]: {method: unRegister, the websocket have no registered"), void (n.registerState = 0); let e = n.constructAndDealSignalNode("unRegister", "single_unRegister_beforeSendUNREGISTER", "single_unRegister_afterReceiveUNREGISTER", "start"); 0 == e ? (n.registerState = 3, n.log("[zteWebrtc]: {method: unRegister, param: " + JSON.stringify([]) + "}", "info"), this.sipNo = null, webrtcWS.unRegister()) : n.log("the result of signal deal is " + e) }, subscribeTheMeetingMembers: function (e, t, r) { n.log("you have register a avc, you cannot subscribe others") }, unSubscribeTheMeetingMembers: function (e, t) { n.log("you have register a avc, you cannot unsubscribe others") }, subscribeZeroScreen: function (e) { n.log("you have register a avc, you cannot subscribeZeroScreen") }, startplay: function () { }, unsubscribeZeroScreen: function () { n.log("you have register a avc, you cannot unsubscribeZeroScreen") }, makeCall: function (e, t, r, i, o, a) { n.log("[zteWebrtc]: {method: makeCall, param: " + JSON.stringify([e, t, i, o, a]) + "}", "info"); var s = this; return new Promise((function (c, l) { if ("string" != typeof e || "" === e) return n.log("[makeCall method] the param of phoneNo is incorrect, please check phoneNo, the phoneNo you have delivered is:" + e), void l({ code: 5, msg: "[makeCall method] the param of phoneNo is incorrect" }); if (1 !== t && 2 !== t) return n.log("[makeCall method] the param of callType is incorrect, please check callType, the callType you have delivered is:" + t), void l({ code: 5, msg: "[makeCall method] the param of callType is incorrect" }); if ("boolean" != typeof r) return n.log("[makeCall method] the param of loose is incorrect, please check loose, the loose you have delivered is:" + r), void l({ code: 5, msg: "[makeCall method] the param of loose is incorrect" }); if (1 != n.registerState) return n.log("[webrtcWS]: WebSocket has not register", "error"), void l({ code: 1, msg: "WebSocket has not register" }); if (1 == s.callStatus) return n.log("[zteWebrtc]: {method: makeCall: you have maked a call", "error"), n.publishEvent("onError", [101, "make call fail, you have maked a call"]), void l({ msg: "[makeCall] you have maked a call" }); if (2 == s.callStatus) return n.log("[zteWebrtc]: {method: makeCall: your call is calling", "error"), n.publishEvent("onError", [102, "make call fail, your call is calling"]), void l({ msg: "[makeCall] your call is calling" }); if (3 == s.callStatus) return n.log("[zteWebrtc]: {method: makeCall: your call is releasing", "error"), n.publishEvent("onError", [103, "make call fail, your call is releasing"]), void l({ msg: "[makeCall] your call is releasing" }); if (4 == s.callStatus) return n.log("[zteWebrtc]: {method: makeCall: your call is called by others", "error"), n.publishEvent("onError", [104, "make call fail, your call is called by others"]), void l({ msg: "[makeCall] your call is called by others" }); n.makecallEvent.callType = 40, n.makecallEvent.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.makecallEvent.data = "0", s.callStatus = 2, s.CsID = zteUtils.generateUUID(), s.checkParams(i, a); let d = s.getConstraints(t, i), u = n.constructAndDealSignalNode("call", "single_makecall_beforeGetUserMedia", "single_makecall_afterGetUserMedia", "start"); 0 == u ? (o.localTag && (s.localTag = o.localTag), o.remoteTag && (s.remoteTag = o.remoteTag), o.subTag && (s.subTag = o.subTag), i.audioOutputId && s.setAudioOut(i.audioOutputId), s.getUserMedia(t, 0, d, i, a).then((() => { let t = n.constructAndDealSignalNode("call", "single_makecall_afterGetUserMedia", "single_makecall_beforeCreateOffer", "middleOfInternal"); if (0 != t) return n.log("the result of signal deal is " + t), void webrtcPC.closePeerConnection(!0); webrtcWS.invite(e, i, a), c(0) })).catch((o => { if (r) if (4 === o.code) { let r = { ...d.video }; d.video = !1, s.getUserMedia(t, 0, d, i, a).then((() => { let t = n.constructAndDealSignalNode("call", "single_makecall_afterGetUserMedia", "single_makecall_beforeCreateOffer", "middleOfInternal"); if (0 != t) return n.log("the result of signal deal is " + t), void webrtcPC.closePeerConnection(!0); n.log("[WEBRTC] getUserMedia: Failed to collect video", "warn"), webrtcWS.invite(e, i, a), c(1) })).catch((o => { if (4 === o.code) d.audio = !1, d.video = r, s.getUserMedia(t, 0, d, i, a).then((() => { n.log("[WEBRTC] getUserMedia: Failed to collect audio", "warn"); let t = n.constructAndDealSignalNode("call", "single_makecall_afterGetUserMedia", "single_makecall_beforeCreateOffer", "middleOfInternal"); if (0 != t) return n.log("the result of signal deal is " + t), void webrtcPC.closePeerConnection(!0); webrtcWS.invite(e, i, a), c(2) })).catch((r => { if (4 === r.code) { let r = "call", o = "single_makecall_afterGetUserMedia", s = "single_makecall_beforeCreateOffer", l = "middleOfInternal", d = n.constructAndDealSignalNode(r, o, s, l); if (0 != d) return void n.log("the result of signal deal is " + d); n.log("[WEBRTC] getUserMedia: Failed to collect video and audio", "warn"), webrtcPC.createPeerConnection(), webrtcPC.addOfferStream(null, t, i, a), webrtcWS.invite(e, i, a), c(3) } else { let e = "call", t = "single_makecall_notSupportWebrtc", i = "no", o = "end", a = n.constructAndDealSignalNode(e, t, i, o); if (0 != a) return void n.log("the result of signal deal is " + a); s.makecallFailedDeal(11), l(r) } })); else { let e = "call", t = "single_makecall_notSupportWebrtc", r = "no", i = "end", a = n.constructAndDealSignalNode(e, t, r, i); if (0 != a) return void n.log("the result of signal deal is " + a); s.makecallFailedDeal(11), l(o) } })) } else { let e = "call", t = "single_makecall_notSupportWebrtc", r = "no", i = "end", a = n.constructAndDealSignalNode(e, t, r, i); if (0 != a) return void n.log("the result of signal deal is " + a); s.makecallFailedDeal(11), l(o) } else { let e = "call", t = "single_makecall_getUserMediaFailAndLooseIsFalse", r = "no", i = "end", a = n.constructAndDealSignalNode(e, t, r, i); if (0 != a) return void n.log("the result of signal deal is " + a); s.makecallFailedDeal(12), l(o) } }))) : n.log("the result of signal deal is " + u) })) }, releaseCall: function () { let e = n.constructAndDealSignalNode("call", "single_releaseCall_beforeSendBYE", "single_releaseCall_afterSendBYE", "start"); 0 == e ? (n.operationInMeeting.operation = 72, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.log("[zteWebrtc]: {method: releaseCall, param: " + JSON.stringify([]) + "}", "info"), n.callStatus = 3, webrtcWS.releaseCall()) : n.log("the result of signal deal is " + e) }, answer: function (e, t, r, i, o) { n.log("[zteWebrtc]: {method: makeCall, param: " + JSON.stringify([e, r, i, o]) + "}", "info"); var a = this; return new Promise((function (s, c) { if (1 !== e && 2 !== e) return n.log("[answer method] the param of callType is incorrect, please check callType, the callType you have delivered is:" + e), void c({ code: 5, msg: "[answer method] the param of callType is incorrect" }); if ("boolean" != typeof t) return n.log("[answer method] the param of loose is incorrect, please check loose, the loose you have delivered is:" + t), void c({ code: 5, msg: "[answer method] the param of loose is incorrect" }); if (1 != n.registerState && (n.log("[webrtcWS]: WebSocket has not register", "error"), c({ code: 1, msg: "WebSocket has not register" })), 1 == a.callStatus) return n.log("[zteWebrtc]: {method: answer: you have maked a call", "error"), n.publishEvent("onError", [101, "answer call fail, you have maked a call"]), void c({ msg: "[answer] you have maked a call" }); if (2 == a.callStatus) return n.log("[zteWebrtc]: {method: answer: your call is calling", "error"), n.publishEvent("onError", [102, "answer call fail, your call is calling"]), void c({ msg: "[answer] your call is calling" }); if (3 == a.callStatus) return n.log("[zteWebrtc]: {method: answer: your call is releasing", "error"), n.publishEvent("onError", [103, "answer call fail, your call is releasing"]), void c({ msg: "[answer] your call is releasing" }); if (4 == a.callStatus) return n.log("[zteWebrtc]: {method: answer: your call is called by others", "error"), n.publishEvent("onError", [104, "answer call fail, your call is called by others"]), void c({ msg: "[answer] answer call is called by others" }); a.callStatus = 4, n.makecallEvent.callType = 40, n.makecallEvent.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.makecallEvent.data = "9", a.checkParams(r, o); let l = a.getConstraints(e, r); i.localTag && (a.localTag = i.localTag), i.remoteTag && (a.remoteTag = i.remoteTag), i.subTag && (a.subTag = i.subTag), r.audioOutputId && a.setAudioOut(r.audioOutputId); let d = n.constructAndDealSignalNode("call", "single_answer_beforeGetUserMedia", "single_answer_afterGetUserMedia", "start"); 0 == d ? a.getUserMedia(e, 1, l, r, o).then((() => { let e = n.constructAndDealSignalNode("call", "single_answer_afterGetUserMedia", "no", "end"); 0 == e ? (webrtcWS.answer(r, o), s(1)) : n.log("the result of signal deal is " + e) })).catch((i => { if (t) if (4 === i.code) { let t = { ...l.video }; l.video = !1, a.getUserMedia(e, 1, l, r, o).then((() => { let e = n.constructAndDealSignalNode("call", "single_answer_afterGetUserMedia", "no", "end"); 0 == e ? (n.log("[WEBRTC] getUserMedia: Failed to collect video", "warn"), webrtcWS.answer(r, o), s(2)) : n.log("the result of signal deal is " + e) })).catch((i => { if (4 === i.code) { let i = "call", d = "single_answer_afterGetUserMedia", u = "no", p = "end", g = n.constructAndDealSignalNode(i, d, u, p); if (0 != g) return void n.log("the result of signal deal is " + g); l.audio = !1, l.video = t, a.getUserMedia(e, 1, l, r, o).then((() => { n.log("[WEBRTC] getUserMedia: Failed to collect audio", "warn"), webrtcWS.answer(r, o), s(3) })).catch((t => { if (4 === t.code) { let t = "call", i = "single_answer_afterGetUserMedia", a = "no", c = "end", l = n.constructAndDealSignalNode(t, i, a, c); if (0 != l) return void n.log("the result of signal deal is " + l); n.log("[WEBRTC] getUserMedia: Failed to collect video and audio", "warn"), webrtcPC.createPeerConnection(), webrtcPC.addOfferStream(null, e, r, o), webrtcWS.answer(r, o), s(4) } else { let e = "call", r = "single_answer_notSupportWebrtc", i = "no", o = "end", s = n.constructAndDealSignalNode(e, r, i, o); if (0 != s) return void n.log("the result of signal deal is " + s); a.makecallFailedDeal(21), c(t) } })) } else { let e = "call", t = "single_answer_notSupportWebrtc", r = "no", o = "end", s = n.constructAndDealSignalNode(e, t, r, o); if (0 != s) return void n.log("the result of signal deal is " + s); a.makecallFailedDeal(21), a.callStatus = 0, c(i) } })) } else { let e = "call", t = "single_answer_notSupportWebrtc", r = "no", o = "end", s = n.constructAndDealSignalNode(e, t, r, o); if (0 != s) return void n.log("the result of signal deal is " + s); a.makecallFailedDeal(21), a.callStatus = 0, c(i) } else { let e = "call", t = "single_answer_getUserMediaFailAndLooseIsFalse", r = "no", o = "end", s = n.constructAndDealSignalNode(e, t, r, o); if (0 != s) return void n.log("the result of signal deal is " + s); a.makecallFailedDeal(22), a.callStatus = 0, c(i) } })) : n.log("the result of signal deal is " + d) })) }, setLocalAudioMuted: function () { return n.log("[zteWebrtc]: {method: setLocalAudioMuted, param: " + JSON.stringify([]) + "}", "info"), n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), "mutedAudience" == n.seminarRole ? (n.log("you are mutedAudience, you can not close or open mic"), -1) : (this.audioMuted ? n.operationInMeeting.operation = 51 : n.operationInMeeting.operation = 50, webrtcPC.setLocalAudioMuted(), this.audioMuted = !this.audioMuted, 0) }, setLocalVideoMuted: function () { return 1 == this.videoFlag ? (n.log("[zteWebrtc]: {method: setLocalVideoMuted, param: " + JSON.stringify([]) + "}", "info"), n.localVideoOpenFlag = !n.localVideoOpenFlag, "guest" != n.seminarRole ? (n.log("you are not guest, you can not close or open camera"), -1) : (n.localVideoOpenFlag ? n.operationInMeeting.operation = 57 : n.operationInMeeting.operation = 56, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), webrtcPC.setLocalVideoMuted(), 0)) : -1 }, setLocalVideoOpen: function () { n.log("[zteWebrtc]: {method: setLocalVideoOpen, param: " + JSON.stringify([]) + "}", "info"), "guest" == n.seminarRole ? 1 == self.localVideoOpenFlag ? webrtcPC.setLocalVideoOpen() : (n.operationInMeeting.data = "setLocalVideoOpen can not implement , localVideoMute is use", n.eventReport(1, 50), n.log("[zteWebrtc]: {method: setLocalVideoOpen can not implement , localVideoMute is use", "warn")) : n.log("you are not guest, you can not open local video") }, setLocalVideoClose: function () { n.log("[zteWebrtc]: {method: setLocalVideoClose, param: " + JSON.stringify([]) + "}", "info"), 1 == self.localVideoOpenFlag ? webrtcPC.setLocalVideoClose() : (n.operationInMeeting.data = "setLocalVideoClose can not implement , localVideoMute is use", n.eventReport(1, 50), n.log("[zteWebrtc]: {method: setLocalVideoClose can not implement , localVideoMute is use", "warn")) }, setLocalAudioOutMuted: function () { n.log("[zteWebrtc]: {method: setLocalAudioOutMuted, param: " + JSON.stringify([]) + "}", "info"), webrtcPC.setRemoteAudioMuted() }, setPerformanceParam: function (e, t, r) { "boolean" == typeof e ? "number" != typeof t || t < 1e3 ? n.log("[setPerformanceParam method] the param of statPeriod is incorrect, please check statPeriod, the statPeriod you have delivered is:" + t) : "number" != typeof r || r < 1e3 ? n.log("[setPerformanceParam method] the param of reportPeriod is incorrect, please check reportPeriod, the reportPeriod you have delivered is:" + r) : (n.log("[zteWebrtc]: {method: setPerformanceParam, param: " + JSON.stringify([e, t, r]) + "}", "info"), webrtcPFM.enabled = e, webrtcPFM.statPeriod = t, webrtcPFM.reportPeriod = r) : n.log("[setPerformanceParam method] the param of enabled is incorrect, please check enabled, the enabled you have delivered is:" + e) }, wssDetection: function (e) { return new Promise((async r => { var i = null; for (const n in e) { e[n] = zteUtils.getAddressType(e[n]), e[n] || r({ status: 1, msg: "detection fail" }); let o = "wss://" + e[n]; if (await t(o)) { i = o; break } } r(i ? { status: 0, url: i } : { status: 1, msg: "detection fail" }) })); function t(e) { return new Promise((t => { var r = new WebSocket(e); window.setTimeout((function () { r && (1 !== r.readyState && t(!1), r.close()) }), 2e3), r.onopen = function (e) { r.close(), t(!0) }, r.onerror = function (e) { t(!1) } })) } }, detection: function (e) { return new Promise((function (t, r) { var i = e.map((function (e) { var t = "wss://" + e; return new Promise((function (e, r) { var i = new WebSocket(t); window.setTimeout((function () { i && 1 !== i.readyState && (i.close(), e()) }), 2e3), i.onopen = function (e) { r(this.url), i.close() }, i.onerror = function (t) { e() } })) })); Promise.all(i).then((function (e) { r(e) })).catch((function (e) { t(e) })) })) }, checkParams: function (e, t) { e.video.cameraid || (e.video.cameraid = webrtcConfig.video.cameraid), e.video.resolution || (e.video.resolution = webrtcConfig.video.resolution), e.video.framerate || (e.video.framerate = webrtcConfig.video.framerate), e.video.rate || (e.video.rate = webrtcConfig.video.rate), e.video.codec || (e.video.codec = webrtcConfig.video.codec), e.video.direction || (e.video.direction = webrtcConfig.video.direction), e.audio.codec || (e.audio.codec = webrtcConfig.audio.codec), e.audio.direction || (e.audio.direction = webrtcConfig.audio.direction), t.enabled && (t.resolution || (t.resolution = webrtcConfig.slides.resolution), t.framerate || (t.framerate = webrtcConfig.slides.framerate), t.rate || (t.rate = webrtcConfig.slides.rate), t.codec || (t.codec = webrtcConfig.slides.codec), t.direction || (t.direction = webrtcConfig.slides.direction)), n.log("[zteWebrtc]: checked media and slides params: {" + JSON.stringify([e, t]) + "}", "info") }, getAudioInList: function () { return this.devices.audioinputArr }, getAudioOutList: function () { return this.devices.audiooutputArr }, getCameraList: function () { return this.devices.videoinputArr }, setAudioIn: function (e) { if ("string" == typeof e && "" !== e) if ("mutedAudience" != n.seminarRole) { var t = this; t.constraints.audio.deviceId = e || void 0, navigator.mediaDevices.getUserMedia({ audio: t.constraints.audio, video: !1 }).then((function (r) { t.updateOnUseDevice(r), t.currentAudioInputDeviceID = e; let i = r.getAudioTracks()[0]; i.enabled = !t.audioMuted; let n = webrtcPC.localStream.getAudioTracks()[0]; n.stop(), webrtcPC.localStream.removeTrack(n), webrtcPC.localStream.addTrack(i), webrtcPC.pc.getSenders()[0].replaceTrack(i) })).catch((function (e) { n.log("[WEBRTC] getUserMedia: " + e, "error") })) } else n.log("you are mutedAudience, you can not choose mic", "error"); else n.log("[setAudioIn method] the param of audioSource is incorrect, please check audioSource, the audioSource you have delivered is:" + e) }, setAudioOut: function (e) { if ("string" == typeof e && "" !== e) { var t = this; t.remoteTag ? void 0 !== t.remoteTag.sinkId ? t.remoteTag.setSinkId(e).then((() => { n.log("[WEBRTC] setAudioOut success, audio output device attached: " + e, "info"), t.onUseDevice.speaker.id = e; for (let r in t.devices.audiooutputArr) if (t.devices.audiooutputArr[r].id == e) { t.onUseDevice.speaker.label = t.devices.audioinputArr[r].label, t.onUseDevice.speaker.id = t.devices.audioinputArr[r].deviceId; break } n.publishEvent("outputAudioChanged", [t.onUseDevice.speaker.id, t.onUseDevice.speaker.label]) })).catch((e => { n.log("[WEBRTC] setAudioOut failed, remoteTag setSinkId error" + e, "error") })) : n.log("[WEBRTC] setAudioOut failed, remoteTag sinkId is undefined", "warn") : n.log("[WEBRTC] setAudioOut failed, remoteTag is null", "error") } else n.log("[setAudioOut method] the param of audioDestination is incorrect, please check audioDestination, the audioDestination you have delivered is:" + e) }, setCamera: function (e) { if ("string" == typeof e && "" !== e) if ("guest" == n.seminarRole) { var t = this; if (t.constraints.video.deviceId = e || void 0, webrtcPC.localStream) { let e = webrtcPC.localStream.getVideoTracks()[0]; e.stop(), webrtcPC.localStream.removeTrack(e) } navigator.mediaDevices.getUserMedia({ video: t.constraints.video, audio: !1 }).then((function (r) { n.updateOnUseDevice(r), t.currentVideoInputDeviceID = e; let i = r.getVideoTracks()[0]; webrtcPC.localStream && (i.enabled = webrtcPC.localVideoflag, webrtcPC.localStream.addTrack(i), webrtcPC.pc.getSenders()[1].replaceTrack(i)) })).catch((function (e) { t.setCamera(n.onUseDevice.camera.id), n.log("[WEBRTC] getUserMedia: " + e, "error") })) } else n.log("you are not guest, you can not setcamera", "error"); else n.log("[setCamera method] the param of videoSource is incorrect, please check videoSource, the videoSource you have delivered is:" + e) }, getDisplayFunc: function () { return new Promise(((e, t) => { if (window.desktopCapturer) console.log("electron desktopCapturer!"), window.desktopCapturer.getSources({ types: ["screen"] }).then((async r => { var i = { audio: !1, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: r[0].id, minWidth: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].width, maxWidth: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].width, minHeight: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].height, maxHeight: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].height, minFrameRate: webrtcPC.slidesParam.framerate, maxFrameRate: webrtcPC.slidesParam.framerate } } }; navigator.mediaDevices.getUserMedia(i).then((t => { e(t) })).catch((e => { t(e) })) })).catch((e => { t(e), console.error("window.desktopCapturer.getSources error:", e) })); else { console.log("webrtc!"); var r = { video: { width: { ideal: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].width }, height: { ideal: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].height }, frameRate: webrtcPC.slidesParam.framerate }, audio: !1 }; navigator.mediaDevices.getDisplayMedia(r).then((t => { e(t) })).catch((e => { t(e) })) } })) }, shareInSub: function () { if ("guest" == n.seminarRole) { if (n.sendSlidesFlag = !0, !(webrtcPC.slidesParam && webrtcPC.slidesParam.resolution && webrtcConfig.resolution && webrtcConfig.resolution[webrtcPC.slidesParam.resolution] && webrtcPC.slidesParam.enabled && "sendrecv" == webrtcPC.slidesParam.direction)) return n.log("[WEBRTC] shareInSubChange, param is null"), n.publishEvent("onSendSubStatus", [3, "no slides"]), n.operationInMeeting.operation = 65, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.operationInMeeting.data = "no slides", void n.eventReport(1, 50); n.operationInMeeting.operation = 58, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.getDisplayFunc().then((e => { let t = n.constructAndDealSignalNode("shareInSub", "single_shareInsub_afterGetDisplayMedia", "single_shareInsub_beforeSendFLOORREQUEST", "start"); if (0 == t) { var r = e.getVideoTracks()[0]; webrtcPC.localVideoSubTrack = r, webrtcWS.getSubStreamToken(), n.regEvent("onBFCP", (function (e) { 1 === e && (n.operationInMeeting.operation = 65, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.eventReport(0, 50), webrtcPC.pc.getSenders()[2].replaceTrack(r), n.publishEvent("onSendSubStatus", [0, ""])), 0 === e && (n.eventReport(1, 50), n.publishEvent("onSendSubStatus", [3, "getSubStreamToken fail"]), webrtcPC.localVideoSubTrack && webrtcPC.localVideoSubTrack.stop()) })), n.regEvent("offBFCP", (function (e) { 1 === e && (n.eventReport(0, 50), n.sendSlidesFlag = !1, webrtcPC.localVideoSubTrack && webrtcPC.localVideoSubTrack.stop(), webrtcPC.pc.getSenders()[2].replaceTrack(null), n.publishEvent("onSendSubStatus", [1, ""])), 0 === e && n.eventReport(1, 50) })), r.addEventListener("ended", (() => { n.operationInMeeting.data = "The user has ended sharing the screen", n.stopShareInSub(), n.log("The user has ended sharing the screen") })) } else n.log("the result of signal deal is " + t) })).catch((e => { n.sendSlidesFlag = !1; let t = n.constructAndDealSignalNode("shareInSub", "single_shareInsub_getDisplayMediaError", "no", "end"); 0 == t ? (void 0 !== e && n.log("[WEBRTC] getDisplayMedia: " + e, "error"), n.operationInMeeting.data = "console the share by someone or something else error such as NotAllowedError", n.eventReport(1, 50), "NotAllowedError" === e.name ? n.publishEvent("onSendSubStatus", [2, "getDisplayMedia error: " + e.name]) : n.publishEvent("onSendSubStatus", [3, "getDisplayMedia error: " + e.name])) : n.log("the result of signal deal is " + t) })) } else n.log("you are not guest, you can not share to else") }, stopShareInSub: function () { this.localVideo && (this.localVideo = null), webrtcPC.localVideoSubTrack && (webrtcPC.localVideoSubTrack.stop(), n.cameraToSubFlag || (n.operationInMeeting.operation = 59, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), n.eventReport(0, 50))), n.operationInMeeting.operation = 67, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), webrtcPC.pc.getSenders()[2].replaceTrack(null), webrtcWS.releaseSubStreamToken() }, getDisplayMedia: function () { n.operationInMeeting.operation = 58, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), navigator.mediaDevices.getDisplayMedia({ video: { width: { ideal: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].width }, height: { ideal: webrtcConfig.resolution[webrtcPC.slidesParam.resolution].height }, frameRate: webrtcPC.slidesParam.framerate }, audio: !1 }).then((function (e) { n.eventReport(0, 50); let t = e.getVideoTracks()[0]; webrtcPC.localVideoSubTrack = t, t.addEventListener("ended", (() => { n.operationInMeeting.data = "The user has ended sharing the screen", n.stopShareInSub(), n.log("The user has ended sharing the screen") })), webrtcPC.pc.getSenders()[2].replaceTrack(t), n.publishEvent("onSendSubStatus", [0, ""]) })).catch((function (e) { n.log("[WEBRTC] getDisplayMedia: " + e, "error"), n.operationInMeeting.data = "console the share by someone", n.eventReport(1, 50), n.stopShareInSub(), "NotAllowedError" === e.name ? n.publishEvent("onSendSubStatus", [2, "user cancel"]) : n.publishEvent("onSendSubStatus", [3, e.message]) })) }, shareInMain: function (e, t) { if (n.operationInMeeting.operation = 58, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), "string" == typeof e && "" !== e) { if ("number" == typeof t && 0 !== t) { var r = this; return new Promise((function (i, o) { let a = { video: { width: { ideal: webrtcConfig.resolution[e].width }, height: { ideal: webrtcConfig.resolution[e].height }, frameRate: t }, audio: !1 }; navigator.mediaDevices.getDisplayMedia(a).then((e => { n.eventReport(0, 50); let t = e.getVideoTracks()[0]; t.addEventListener("ended", (() => { n.log("The user has ended sharing the screen"), r.stopShareInMain() })); let o = webrtcPC.localStream.getVideoTracks()[0]; o ? (o.stop(), webrtcPC.localStream.removeTrack(o)) : n.log("the main video track have sth. wrong, maybe you have no camera;"), webrtcPC.localStream.addTrack(t), webrtcPC.pc.getSenders()[1].replaceTrack(t), i(0) })).catch((e => { n.operationInMeeting.data = "get displaymedia error", n.eventReport(1, 50), "NotAllowedError" === e.name ? i(1) : o({ code: 1, msg: e.message }) })) })) } n.log("[shareInMain method] the param of framerate is incorrect, please check framerate, the framerate you have delivered is:" + e) } else n.log("[shareInMain method] the param of resolution is incorrect, please check resolution, the resolution you have delivered is:" + e) }, stopShareInMain: async function () { n.operationInMeeting.operation = 59, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1); var e = this; return new Promise((function (t, r) { if (e.constraints.video) navigator.mediaDevices.getUserMedia({ video: e.constraints.video, audio: !1 }).then((function (r) { e.updateOnUseDevice(r), n.eventReport(0, 50); let i = r.getVideoTracks()[0], o = webrtcPC.localStream.getVideoTracks()[0]; o.stop(), webrtcPC.localStream.removeTrack(o), webrtcPC.localStream.addTrack(i), webrtcPC.pc.getSenders()[1].replaceTrack(i), t(0) })).catch((function (e) { n.operationInMeeting.data = "getusermedia failed when stop shareInmain", n.eventReport(1, 50), n.log("[WEBRTC] getUserMedia: " + e, "error"), r({ code: 1, msg: e.message }) })); else { let e = webrtcPC.localStream.getVideoTracks()[0]; e.stop(), webrtcPC.localStream.removeTrack(e), t(0) } })) }, getDevicesAfter: function () { self = this; var e = 1, t = 1, r = 1; return new Promise((function (i, o) { navigator.mediaDevices && navigator.mediaDevices.enumerateDevices ? navigator.mediaDevices.enumerateDevices().then((o => { self.devices.audioinputArr = [], self.devices.audiooutputArr = [], self.devices.videoinputArr = []; for (let i = 0; i !== o.length; ++i) { var a = o[i].toJSON(); n.log(a.kind + ":" + a.label + ",id:" + a.deviceId), "audioinput" === a.kind ? (0 === a.label.length && (a.label = "audioinput" + e, console.log(a.label), e += 1), self.devices.audioinputArr.push(a)) : "audiooutput" === a.kind ? (0 === a.label.length && (a.label = "audiooutput" + t, console.log(a.label), t += 1), self.devices.audiooutputArr.push(a)) : "videoinput" === a.kind ? (0 === a.label.length && (a.label = "videoinput" + r, console.log(a.label), r += 1), self.devices.videoinputArr.push(a)) : n.log("[WEBRTC]get devices other kind") } i({ audioInputNum: e, audioOutputNum: t, videoInputNum: r }) })).catch((e => { o({ code: 3, msg: e.message }), n.log("[WEBRTC] get devices fail:" + err) })) : (o({ code: 1, msg: "not support webrtc" }), n.log("[WEBRTC]WEBRTC API: not support webrtc")) })) }, getDevices: function () { return self = this, new Promise((function (e, t) { self.getDevicesAfter().then((r => { r.audioInputNum > 1 || r.audioOutputNum > 1 || r.videoInputNum > 1 ? (console.log("getDevices do not have promise!"), navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? navigator.mediaDevices.getUserMedia({ video: !0, audio: !0 }).then((() => { self.getDevicesAfter().then((() => { e(self.devices) })).catch((e => { t(e), console.error("getDevicesAfter1:", e) })) })).catch((r => { self.getDevicesAfter().then((() => { e(self.devices) })).catch((e => { t(e), console.error("getDevicesAfter2:", e) })) })) : (t({ code: 1, msg: "not support webrtc" }), n.log("[WEBRTC]WEBRTC API: not support webrtc"))) : e(self.devices) })).catch((e => { t(e), console.error("getDevicesAfter3:", e) })) })) }, getUserMedia: function (e, t, r, i, o) { var a = this; return new Promise((function (s, c) { navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? navigator.mediaDevices.getUserMedia(r).then((function (l) { r && r.video && r.video.deviceId && (a.currentVideoInputDeviceID = r.video.deviceId), r && r.audio && r.audio.deviceId && (a.currentAudioInputDeviceID = r.audio.deviceId), a.updateOnUseDevice(l), n.publishEvent("onLocalStream", [l]), n.localTag && (n.localTag.muted = !0, n.localTag.srcObject = l), window.RTCPeerConnection ? (null == webrtcPC.pc && webrtcPC.createPeerConnection(), 0 === t && webrtcPC.addOfferStream(l, e, i, o), 1 === t && webrtcPC.addAnswerStream(l, e, i, o), s()) : (n.log("[WEBRTC] RTCPeerConnection: create PeerConnection fail", "error"), c({ code: 2, msg: "not support webrtc" })) })).catch((function (e) { n.log("[WEBRTC] getUserMedia: " + e.message, "warn"), c({ code: 4, msg: e.message }) })) : (n.log("[WEBRTC]WEBRTC API: not support webrtc", "error"), c({ code: 2, msg: "not support webrtc" })), navigator.mediaDevices.ondevicechange = function (e) { n.log("devices have been changed"), a.getDevices().then((() => { if (a.devicesStr === JSON.stringify(a.devices)) return void console.warn("devicesStr is same"); a.devicesStr = JSON.stringify(a.devices), console.info(JSON.stringify(a.devices)), n.publishEvent("deviceChanged", [0, ""]); let e = !0, t = !0; if (a.devices.audioinputArr.length ? (n.log("the device changed have effect the current audio input device"), a.setAudioIn(a.devices.audioinputArr[0].deviceId)) : n.log("have no audio input device for use, please check mic"), a.devices.audiooutputArr.length ? (n.log("the device changed have effect the current audio ouput device"), a.setAudioOut(a.devices.audiooutputArr[0].deviceId)) : n.log("have no audio out device for use, please check mic"), a.devices.videoinputArr.length) { for (let r in a.devices.videoinputArr) a.onUseDevice.camera.id == a.devices.videoinputArr[r].deviceId && (e = !1, n.log("the device change are not the current vidoe device")), a.cameraToSubFlag ? a.currentSlideVideoInputDeviceID && a.currentSlideVideoInputDeviceID == a.devices.videoinputArr[r].deviceId && (t = !1, n.log("the device change not the current slide video device")) : (t = !1, n.log("no share camera to slides")); e && (n.log("the device changed is the current vidoe device"), a.setCamera(a.devices.videoinputArr[0].deviceId)), t && (n.log("the device changed is the current slide vidoe device"), a.switchCameraDynamic(a.devices.videoinputArr[0].deviceId, "1080P", 15)) } else a.onUseDevice.camera.id = "", n.log("have no video device for use, please check camera") })).catch((e => { n.log("update device failed after device changed err:" + e) })) } })) }, cameraToSubStream: function (e, t, r, i) { if ("string" != typeof e || "" === e) return void n.log("[cameraToSubStream method] the param of cameraID is incorrect, please check cameraID, the cameraID you have delivered is:" + e); if ("string" != typeof t || "" === t) return void n.log("[cameraToSubStream method] the param of resolution is incorrect, please check resolution, the resolution you have delivered is:" + t); if (!r || "number" != typeof r || 0 === r) return void n.log("[cameraToSubStream method] the param of framerate is incorrect, please check framerate, the framerate you have delivered is:" + r); if (!webrtcPC.slidesParam.enabled || "sendrecv" !== webrtcPC.slidesParam.direction) return void n.publishEvent("onSendSubStatus", [3, "no slides"]); n.sendSlidesFlag = !0, n.operationInMeeting.operation = 65, n.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1); var o = this; o.cameraToSubConstraints(e, t, r), i && (o.localVideo = i), n.regEvent("onBFCP", (function (e) { 1 === e && (o.cameraToSubFlag = !0, n.eventReport(0, 50), n.getUserMediaByCameraID()), 0 === e && (n.eventReport(1, 50), n.publishEvent("onSendSubStatus", [3, "getSubStreamToken fail"])) })), n.regEvent("offBFCP", (function (e) { 1 === e && (n.eventReport(0, 50), n.sendSlidesFlag = !1, o.cameraToSubFlag = !1, webrtcPC.localVideoSubTrack.stop(), webrtcPC.pc.getSenders()[2].replaceTrack(null), n.publishEvent("onSendSubStatus", [1, ""])) })); let a = n.constructAndDealSignalNode("shareInSub", "single_shareInsub_cameraToSubStream", "single_shareInsub_beforeSendFLOORREQUEST", "start"); 0 == a ? webrtcWS.getSubStreamToken() : n.log("the result of signal deal is " + a) }, getUserMediaByCameraID: function () { var e = this; navigator.mediaDevices.getUserMedia({ video: e.constraintsForCameraChoose.video, audio: !1 }).then((function (t) { e.constraintsForCameraChoose && e.constraintsForCameraChoose.video && e.constraintsForCameraChoose.video.deviceId && (e.currentSlideVideoInputDeviceID = e.constraintsForCameraChoose.video.deviceId), e.updateOnUseDevice(t), e.localVideo && (e.localVideo.srcObject = t); let r = t.getVideoTracks()[0]; webrtcPC.localVideoSubTrack ? (webrtcPC.localVideoSubTrack.stop(), webrtcPC.localVideoSubTrack = r) : webrtcPC.localVideoSubTrack = r, webrtcPC.pc.getSenders()[2].replaceTrack(r), r.addEventListener("ended", (() => { n.log("The user has ended sharing the screen") })), n.publishEvent("onSendSubStatus", [0, ""]) })).catch((function (t) { e.cameraToSubFlag && webrtcWS.releaseSubStreamToken(), n.log("[WEBRTC] getDisplayMedia: " + t, "error"), "NotAllowedError" === t.name ? n.publishEvent("onSendSubStatus", [2, "user cancel"]) : n.publishEvent("onSendSubStatus", [3, t.message]) })) }, switchCameraDynamic: function (e, t, r) { "string" == typeof e && "" !== e ? "string" == typeof t && "" !== t ? r && "number" == typeof r && 0 !== r ? (n.cameraToSubConstraints(e, t, r), n.getUserMediaByCameraID()) : n.log("[switchCameraDynamic method] the param of framerate is incorrect, please check framerate, the framerate you have delivered is:" + r) : n.log("[switchCameraDynamic method] the param of resolution is incorrect, please check resolution, the resolution you have delivered is:" + t) : n.log("[switchCameraDynamic method] the param of cameraID is incorrect, please check cameraID, the cameraID you have delivered is:" + e) }, cameraToSubConstraints: function (e, t, r) { if ("1080P" === t); else if ("720P" !== t) return void n.log("the resolution you have input ia wrong"); this.constraintsForCameraChoose = { video: { width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: r, aspectRatio: 16 / 9, resizeMode: "crop-and-scale", deviceId: e }, audio: !1 } }, audioAndVideoSwitch: function () { this.videoFlag ? this.videoFlag = !1 : this.videoFlag = !0, this.videoFlag ? (this.operationInMeeting.operation = 69, this.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), webrtcWS.AudioToVideo()) : (this.operationInMeeting.operation = 68, this.operationInMeeting.eventTime = zteUtils.getNowFormatDate(new Date, !1), webrtcWS.VideoToAudio()) }, chooseFrontBackCamera: function (e) { var t = this; let r = null; if ("front" == e) r = "user"; else { if ("back" != e) return n.log("[WEBRTC] chooseFrontBackCamera: change camera is not front or back!"), 1; r = "environment" } let i = { facingMode: r, height: { ideal: 720 }, width: { ideal: 1280 } }; return 1 != webrtcPC.localVideoflag ? (console.error("chooseFrontBackCamera.localVideoflag is not true:", webrtcPC.localVideoflag), 3) : (navigator.mediaDevices.getUserMedia({ video: i, audio: !1 }).then((function (e) { t.updateOnUseDevice(e); let r = e.getVideoTracks()[0]; if (webrtcPC.localStream && r) { let e = webrtcPC.localStream.getVideoTracks()[0]; e && (e.stop(), webrtcPC.localStream.removeTrack(e)), r.enabled = !0, webrtcPC.localStream.addTrack(r), webrtcPC.pc.getSenders()[1].replaceTrack(r) } })).catch((function (e) { return n.log("[WEBRTC] chooseFrontBackCamera.getUserMedia: " + e, "error"), 2 })), 0) }, eventReport: function (e, t) { 40 == t ? (n.makecallEvent.eventResult = e, n.makecallEvent.eventDuration = zteUtils.getDuration(n.makecallEvent.eventTime), webrtcPFM.event(40)) : 50 == t ? (n.operationInMeeting.eventResult = e, n.operationInMeeting.eventDuration = zteUtils.getDuration(n.operationInMeeting.eventTime), webrtcPFM.event(50)) : n.log("the eventCode is not define") }, getConstraints: function (e, t) { var r = { video: !1, audio: { noiseSuppression: !0, echoCancellation: !0, autoGaincontrol: !0 } }; if (t.audio.deviceId && (r.audio.deviceId = t.audio.deviceId), 2 === e) { let e = t.video.resolution; e && (r.video = { width: { ideal: webrtcConfig.resolution[t.video.resolution].width }, height: { ideal: webrtcConfig.resolution[t.video.resolution].height }, frameRate: t.video.framerate, aspectRatio: 16 / 9, resizeMode: "crop-and-scale" }, "VGA" === e && (r.video.aspectRatio = 4 / 3)), t.video.deviceId && (r.video.deviceId = t.video.deviceId) } return this.constraints = r, r }, resetStatus: function () { this.currentVideoInputDeviceID = null, this.currentAudioInputDeviceID = null, this.currentAudioOutputDeviceID = null, this.currentSlideVideoInputDeviceID = null, this.audioMuted = !1, this.localVideoOpenFlag = !0, this.videoFlag = !0, this.callStatus = 0, this.HPCodeAbility = null, this.floorTokenHoldStatus = 0, this.sendSlidesFlag = !1, this.seminarRole = "guest" }, setSeminarRole: function (e) { return 1 != n.callStatus ? (n.log("the call status is not on talking, you can not set seminar role"), n.publishEvent("onSetSeminarRole", [4, "call status error"]), -1) : "guest" != e && "mutedAudience" != e && "audience" != e ? (n.log("the role you want to set is invalid, please check your role witch you input", "error"), n.publishEvent("onSetSeminarRole", [1, "Parameter error"]), -1) : e == n.seminarRole ? (n.log("The current role is consistent with the role to be set", "error"), n.publishEvent("onSetSeminarRole", [2, "role repeat set"]), -1) : "guest" === e ? 0 == n.closeAudioAndVideo(!0) ? (n.localVideoOpenFlag = !1, n.seminarRole = e, n.publishEvent("onSetSeminarRole", [0, "set guest role successfully"]), 0) : (n.publishEvent("onSetSeminarRole", [3, "set guest role failed because of muted audio or video"]), -1) : "mutedAudience" === e ? 0 == n.closeAudioAndVideo(!1) ? (n.localVideoOpenFlag = !1, n.seminarRole = e, n.stopShareInSub(), n.publishEvent("onSetSeminarRole", [0, "set mutedAudience role successfully"]), 0) : (n.publishEvent("onSetSeminarRole", [3, "set mutedAudience role failed because of muted audio or video"]), -1) : 0 == n.closeAudioAndVideo(!0) ? (n.localVideoOpenFlag = !1, n.seminarRole = e, n.stopShareInSub(), n.publishEvent("onSetSeminarRole", [0, "set audience role successfully"]), 0) : (n.publishEvent("onSetSeminarRole", [3, "set audience role failed because of muted audio or video"]), -1) }, closeAudioAndVideo: function (e) { let t = webrtcPC.setLocalAudioClose(), r = webrtcPC.setLocalVideoClose(); return 0 == t && 0 == r ? (n.log("[single] audio and video mute success"), 0) : (n.log("[single] audio or video mute failed, and the audioMuteResult is " + t + "; ideoMutedResult is " + r, "error"), -1) }, publishEvent: function (e, t) { n.log("[zteWebrtc]: event: " + e + " , args=[" + JSON.stringify(t) + "]", "info"), n.EventBus.dispatchEvent(e, t), setTimeout((function () { n.EventBus.dispatchEvent("onEvent", [e, t]) }), 0) }, regEvent: function (e, t) { return this.EventBus.addEventListener(e, t) }, unregEvent: function (e) { this.EventBus.removeEventListener(e) }, log: function (e, t) { if (webrtcConfig.logger.console && (n.logger.console_log(e, t), webrtcConfig.logger.upload)) { var r = this.sipNo ? this.sipNo : "default"; n.logger.http_log(e, r, t) } }, constructAndDealSignalNode: function (e, t, r, i) { if (!webrtcConfig.timeoutJudgment) return 0; let o = { signalType: e, currentSignalCode: t, expectedSignalCode: r, timer: null, signalStausCode: i }; return n.signalDeal(o, n.CsID) }, signalDeal: function (e, t) { if (n.log("[signalDeal] the param is " + JSON.stringify([e, t])), t != n.CsID) return n.log("[signalDeal] csid id not current, current csid is " + n.CsID + ";this csid is " + t), 4001; if ("start" == e.signalStausCode) return n.log("[signalDeal] we receive a begin signal, we will push in signalArray"), n.findSignalFromSignalArray(e) > -1 ? 4004 : (n.signalArray.push(e), e.timer = setTimeout((() => { n.signalTimeoutDeal(e) }), webrtcConfig.timeoutOfsignal), 0); let r = n.findSignalFromSignalArray(e); return -1 == r ? (n.log("[signalDeal] we can not find signal in signalArray, ignore; and the error signal is " + JSON.stringify([e])), "end" == e.signalStausCode ? 0 : 4002) : (n.log("[signalDeal] The index of the currently processed signal in the signalArray is " + r), "end" == e.signalStausCode ? (n.log("[signalDeal] we receive a end signal"), n.signalArray[r].timer && (clearTimeout(n.signalArray[r].timer), n.signalArray[r].timer = null), n.log("[signalDeal] The signal with index " + r + "will be deleted from the signalArray"), n.deleteSignalFromSignalArray(r), 0) : n.signalArray[r].expectedSignalCode == e.currentSignalCode ? (n.log("[signalDeal] We will restart the timer for the current signal"), n.signalArray[r].timer && (clearTimeout(n.signalArray[r].timer), n.signalArray[r].timer = null), n.signalArray[r] = e, n.signalArray[r].timer = setTimeout((() => { n.signalTimeoutDeal(e) }), webrtcConfig.timeoutOfsignal), 0) : (n.log("[signalDeal] The current out-of-order signal will be discarded"), 4003)) }, findSignalFromSignalArray(e) { let t = -1; for (let r = 0; r < n.signalArray.length; r++)if (n.signalArray[r].signalType == e.signalType) { t = r; break } return t }, signalTimeoutDeal: function (e) { n.log("[signalDeal] timeout signal is:" + JSON.stringify([e]), "error"); let t = n.findSignalFromSignalArray(e); if (-1 != t) switch (n.deleteSignalFromSignalArray(t), console.log("signalTimeoutDeal"), e.signalType) { case "register": "middleOfExternal" === e.signalStausCode && webrtcWS.unRegister(), webrtcWS.close(), n.registerFailedDeal(e.currentSignalCode); break; case "call": "middleOfExternal" === e.signalStausCode || "single_answer_beforeGetUserMedia" === e.currentSignalCode || "signal_answer_beforeSetRemoteDescription" === e.currentSignalCode ? (console.log("[signalTimeoutDeal]: in middleOfExternal"), webrtcWS.releaseCall(), n.resetStatus()) : (console.log("[signalTimeoutDeal]: not in a call"), webrtcPC.closePeerConnection(!0), n.publishEvent("onRelease", [""]), n.resetStatus()), n.makecallFailedDeal(e.currentSignalCode); break; case "receiveFloor": break; case "audioAndVideoSwitch": "single_videoToAudio_beforeSendAudioToVideo" == e.currentSignalCode ? (n.videoFlag = !1, n.publishEvent("switchAudioAndVideo", [1, "102"])) : "single_videoToAudio_beforeSendVideoToAudio" == e.currentSignalCode && (n.videoFlag = !0, n.publishEvent("switchAudioAndVideo", [1, "101"])); break; case "shareInSub": "middleOfExternal" === e.signalStausCode && (console.log("[signalTimeoutDeal]:shareInSub middleOfExternal"), n.stopShareInSub()), n.publishEvent("onBFCP", [0]) } else n.log("we can not find singal in Array") }, deleteSignalFromSignalArray: function (e) { return n.signalArray.length && n.signalArray[e] ? (n.signalArray.splice(e, 1), 0) : (n.log("[signalDeal] zteWebrtc.signalArray.length is null", "error"), -1) }, sleep: function (e) { let t = (new Date).getTime(); for (; (new Date).getTime() - t < e;); } }; n.EventBus = { eventHanderMap: {}, interceptMap: {}, idHandlerMap: {}, index: 2e3, dispatchEvent: function (e, t) { var r = this.eventHanderMap[e]; if (null != r) for (var i = r.concat(new Array), o = 0; o < i.length; o++) { var a = i[o]; if ("function" == typeof a || "object" == typeof a) { var s = null; null != t && "object" == typeof t && "number" == typeof t.length && (s = t); try { if (null == s) a.apply(a.prototype); else { jsArgs_ = new Array; for (var c = 0; c < s.length; c++)jsArgs_[c] = s[c]; "function" == typeof a ? a.apply(window, jsArgs_) : a.call(window, jsArgs_) } } catch (r) { n.log("[zteWebrtc]: publish event[e=" + e + ",args=" + t + "] error!" + r, "error") } } } }, addEventListener: function (e, t) { var r = new Array; return r.push(t), this.eventHanderMap[e] = r, this.index++, this.idHandlerMap[this.index] = [e, t], this.index }, removeEventListener: function (e) { if (this.idHandlerMap[e]) { var t = this.idHandlerMap[e][0], r = this.idHandlerMap[e][1]; this.idHandlerMap[e] = null; var i = this.eventHanderMap[t]; if (i) for (var n = 0; n < i.length; n++)i[n] == r && this.eventHanderMap[t].splice(n, 1) } }, removeAllEventListener: function () { this.eventHanderMap = {} } }, n.logger = { level: "info", console_log: function (e, t) { if (window.console) { t || (t = this.level); var r = console[t]; r && ("function" == typeof r ? console[t](e) : r([e])) } }, http_log: function (e, t, r) { r || (r = this.level), logger[r](e, t) } }, n.script = { loadjsMap: {}, load: function (e, t) { if (this.loadjsMap[e]) t && t(); else { var r = !1, i = document.createElement("script"); i.type = "text/javascript", i.language = "javascript", i.src = e; var n = this; n.loadjsMap[e] = !0, i.onload = i.onreadystatechange = function () { r || i.readyState && "loaded" != i.readyState && "complete" != i.readyState || (r = !0, n.loadjsMap[e] = !0, i.onload = i.onreadystatechange = null, t && t.call(i)) }, document.getElementsByTagName("head")[0].appendChild(i) } }, loadJs: function (e, t) { if (e.length < 1) t && t(); else { var r = this, i = e.shift(); this.load(i, (function () { r.loadJs(e, t) })) } } }, void 0 === (i = function () { return n }.call(t, r, t, e)) || (e.exports = i) } }, t = {}; function r(i) { var n = t[i]; if (void 0 !== n) return n.exports; var o = t[i] = { exports: {} }; return e[i].call(o.exports, o, o.exports, r), o.exports } r.amdD = function () { throw new Error("define cannot be used indirect") }, r.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return r.d(t, { a: t }), t }, r.d = (e, t) => { for (var i in t) r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { "use strict"; r(950); var e = r(375), t = r.n(e), i = r(735), n = r.n(i), o = r(182), a = r.n(o), s = r(879), c = r.n(s), l = r(783), d = r.n(l), u = r(533), p = r.n(u), g = r(515), f = r.n(g), h = r(363), m = r.n(h), S = r(129), b = r.n(S), T = r(653), v = r.n(T); class C { static get version() { return "1.2.9" } get config() { return { wssUrl: this._wssUrl, sipUrl: this._sipUrl, logUrl: this._logUrl, heartbeatTime: this._heartbeatTime, connectTimeout: this._connectTimeout, socketTimeout: this._socketTimeout } } get call() { return this._call } get state() { return this._call.state } get sipNo() { return this._sipNo } get agentId() { return this._agentId } get autoAnswer() { return this._autoAnswer } set autoAnswer(e) { (e = !!e) != this._autoAnswer && (this._autoAnswer = e, this._log("info", (e ? "enable" : "disable") + " automatic answer")) } constructor(e, t) { if ("[object HTMLVideoElement]" != e?.toString()) throw new Error("localTag must be HTMLVideoElement"); if ("[object HTMLVideoElement]" != t?.toString()) throw new Error("remoteTag must be HTMLVideoElement"); this._mediaParam = { audio: { deviceId: null }, video: { cameraid: null } }, this._mediaTag = { localTag: e, remoteTag: t }, this._slidesParam = { enabled: !1 }, this._action = {}, this._eventHandlers = { online: new Set, offline: new Set, ringing: new Set, talking: new Set, released: new Set, answering: new Set, answered: new Set }, this._online = !1, this._call = { callid: "", calling: "", called: "", ringTime: null, answerTime: null, releaseTime: null, state: "released" }, this._hangAudioPlayer = new WebAudioPlayer("SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAUAAAdcQAXFxcXKSkpKSk7Ozs7O0dHR0dHUlJSUlJdXV1dXWdnZ2dndHR0dHR+fn5+fomJiYmJk5OTk5OgoKCgoKqqqqqqtbW1tbXCwsLCws7Ozs7O2dnZ2dnl5eXl5fHx8fHx//////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAJAAAAAAAAAHXHe9cUXAAAAAAD/+6DEAAAAAAH+AAAAITifojaWUAANiTIEGRohgfL339m6io/AIAOA8D4SB4CAiyMA4uJi5FOcQY7HOHxM5FRFfQOMfIQhCK8jeStCXIt2Ez1Oc5Lqf57f8hCNV9GExd6RBxOqRZZqVYEAAQRUkyrKSSAgAuzbc1byUqz1oF5ksn6UeJQBwEFkqC7wOwW4U1hikVOyxpbWmQTSgrTX2fu2ztQ/kTi8sXvDreiS4g1h1KWtM2c5p8Yeluo3G7sMqntUe5fS1ZTIYircq1mEjYJKYtACQkXkvMrVBYvRF+Kk/Ca7qSp9H4kfbEEROX4343IqkigC9M1pJQ7sdylD+NPmJY88MQ5hnz8f///+/X7r///+BkvFLHPjFjIwigAgqkuREYmhnvmkmUTSwAMEZpqCSgJlxcYCLhjQZCAmrsYY/A0YOCMwgmGrcioDazEyMVYGASwyiUtCWaTieIHDzDRDSCwcJRyEhI8LEYZH0Ejh00hMUufEiHpTA4Aw92AMNTlccDASoLLus9WYQgJKwAiBkAcuOnCXMS2UXY3KIfAIZgbwrYceDYEcJPWVNWXxfaAxNTWG2cuqsVEGMOQs1Td0kv2ZrpYe3dri+HiYfPLLYI9DMU9XcUvU0dubZw2ROx3GgPxEpU11XTWm6OO1GEzjqygw4hRZcqAGxjzLLT20Nm9Fv///2RrzUOf/+6DE0wAW9Tcj+YwSC8emo/83oADyQ2a6YrpLpWQycRdQ91eqzGxwAMuxcyIEDEI0BwiIQW0k1W3SIFmER0YSD7Kg4ZBBXMUlcQAAQDcGiExuDTEA2GGPEBhMHAjNFB5kVIZEYCwEdAIPMcOIsDipg0jLVL1dkgEiALTL9IbmsNA4Y4hgRKwCnmftHLpLeb5iwFBBhIyA5AYYQIjSXKYIpi/BaVA6LwIJDUAKUxeJOciEonongkAzZriARjLgIlp6uDOOU1pXTW3Kc59LLFXjc2Vt8vuafqVtTetfD20szOsJi1M3KKyjjjROH3+Zg2zKHmYmgc4qa6s//rD/+DWjLWnIRz/1/vy78uikfeR//spgcAEAAWAAACezrmrjkgAMCxxMvwfMGBzMVwNMBg5Mz31Dh3MtDMMGAGMbC6Og2lNPDvGAlMDh0NIB/Mch5MrAZCwqme0RjK2a4Hkh0YsVmPxh1RSchnmrPICT0IgFXmCgQENTIQQ2x1NFIx0IMTDgwAMhIFZBoQMFEBglIBYVC4ISuLvNeXcIQMwkAYQtgRBqdoCH0biggi7ImVNULdstc0OAE8oAQqXY0tpFCXai6AuJwY98EMWVif1wZEz91YKWHIgdubXX1pIbT3Xq50TsOWtemcqC4Ebuw9x1jK2OCylprJXqlj/tLZfAfLjD7DPXqedx3i7///v/+6DE+IAe8TMn+c0CBC6no787sADDx3mUtrh//r2tl1oXLpfz/+9V8gAAZQQCPGk8DgMEzA84kXTAgIzBQFzCA2TJERDJcbDDEJjBABTAQAXFCAtBwAuFVS1VhKZ7580lenyUFq5bkJFRyt4VIWler6/rWkyuWo7jCWTxzOUdmUdpNhWtTVntWmjdeC7Nrszk5cPzc1Wzw7hlex3e3y5dwxqd+m1lO87XlVijm7N7Ga1jM3ZblrmVJyvXtzeFWKWodzpqe1TPvRy+UXXxQ6bxfDeq84CLAEMdEAQBgZDhGCAYYKG4iAAUx5i4oGCwCODQaCCJ5h4BmugoVK+WiAI2Goz2zfZC01Fi5lYZGUxkQCsPG8CqoiGRUy+5BoNJYrZZe/zD0JaqbOHcZdJh0ACZzu0Z1mYysKQIJAsHzSxECCHUEGia3tyfqbWYrTJcwwosaogU0zyACCXA+wYJg+wqygs3BCXnAgFROSGBQialKyGyelBRRg6IXakIAIZkBAR9TBAGAwVgIw+HwAQ1Dgo1TiAEayEC8wQAUKjAoAMpiSyaB2cGCKJozuftELAwQMmpjUmIBA3C1ZdKY6SCs2VoqbpKUeIl9R+33a3ahqcqYQQMjiVM5dDQJNPpcLHj4XG0kLA+LKtSQI9KRRxWtEMkMppuGLRtV7l41ebfqM3IYzVggNqKQi4fonH/+4DE8QAVcRkt/dwAIpki5HXMpXwE4KkjazeJBACXQAECO0gQASFSYICQeJgAy8wwaTsAWhsHFYxkBR0DGMBETsV5R7rkhzmV1vv0kPrCQLhasPEbTy/OTdflCxg/cbMwIxNpjAzqTSumA3IdrYCgx9rKxLaIzYkGwIDYwNiglECJbSPMklbcEmmOYuJ2OFkcqc+UvbKavm3BEpu5JotcKJE2CZDqusRxsQNrssWqGQBjQxQWfDCQBwkq5MCiIxANFTmCh0AzSTAkGBsLgFggBBQYVmjtxlywQAz4p6TKAx0LLkN4bobsFBLCIU3doGYhgFOsvwiKx1W8ayubJpjSJXF5l1SqOUbJ0LJOUFDCMFB0cxZUKNolu1ses9MhlsiNCTxSpRWbIhReclrhGMmxtGkwSPXksZrpktQo/mwjPJID7OmAVoBBjkkhgwQGSYfBATBgUj5hyfHKiONBQwmFwCE0zRACAcB5DP01Rf/7cMT0ABLhFynuZSviSKNlPcwlfA4eSDFLdyJMAUqRilMQnIACDGJCqwxGlZgA1Vkm3YlYIO4/0rK0v2cui4z8wS3YLDPyyONVJspJYgaJxUJBIICpOSTQXqDuV6sbtY/eeJFBFw6gIrbW1fSZDE+qjVNCtCzkYIC0KI7cki3XtrkQe/6kdNVKAHJCAwQ7SKoEI8ClMHNYAFosBfQdM1NggvHhOQolA5HjczhAoqEdH/OzDtL1Xt2tZyBaHs1SUxVAkpdvf3yqCm3dfhvXVmpVI4rSBQS7+nWkbjKFASFGtWIQrNzU2jul5ut79b8c2Wbys7GFzj3e6w6hzyerFbRM8cS8+SlxSP257WUsbDx5Vsg7VPLckSvUzVKBrCCIO0QQAIAAcY25mCQkhNMAyA36JRYJGQAmNAf/+3DE8QASlRcr7mEr4m4ipLXMJpRAKMD8imYO9808aCUnyk9mnwZ+26o7n1pIZbKUbesTiwVQAXaZ9rD8RGLO5tQrPEnw3jrxaDLhKYeN/eFiI6Q2NA84JxwpOAoOQ9uV4mbn78e3ftS7u07bx8jivLi+zGHzDl1tV+oqTblsBw5J61kBU5baG94bL34lFAoYAFHIAABgAHiXwcFie4sBJiCjB1+GZgOAQkNqRCqIBAsBIFxOXTy8QFDXIlSv5F32fibU5fa68kINBEEgSFqsiqCuQ5UtKTb50FBUs5Qx4kAp0pQM7i+bBGlkpQbMtLMWZPHnFgjnI8BQTSbeo5PF26+tHJu03jEFVy9p6Chatz8aAbJHF7CsvHq44fOVbK5wqRFeSxDYzKhw6djmJLlZYSmrwgBAAAA6//twxOqAEk0TK+3hjaJcoyT1zLF8AFCAmA0DAKYMgEmoYajqdDgcLA0AgMWxDYEAEaAij1C3cRPOUTcSjtSxVZR2Gn3o3enTPtaenzwaOUBh4LINZvUSHJRNsebquRTEiEtcjsqboke1G5eqT01T0lfKbeIBkhg2iA2JVjC61H9WZqUCzHOacQNrTpJGyISEMI4NrEKq5MofXghQkvkjIioqI0RZVSTHI0ZMywRoz2JZAFRyAgZ7SZAMLmEwgIQgwiILsIMEs046GkwwUDCAEF90GxoGHxGDBT9jgYHTl3crzS67+UlLnUMBCFR2zaEYKH6dfce2FdrhzbG2BfTA3beWmtS1DuaWs0+VDj+zT4MywhA6SjAurqOww5HdZS9mnvdujglk4eEmTfGUb5qnNiSnHszJZxDVYf/7gMTngFStGR+u6YvigSNkNd0lvCSQ9MuHmUibv+ubVzmIO51JAHJQAQZ7JBAMNBkt2YRABgsAkACHZiYzISQ4qKhoCQOTAkHyeRduqdCYMypZr7Tws5cypc7o5zVZvGCSFYiQqa7b1MkF6exCIvD7Q5A/cNySQiOIRatgtRFFZAmAc2VWGHICPfOkScVZVG9xuc1Ze5YtFVBBN0oGV2YMIZldohqerpGJDDaNaApSRoU1IkrB62kAZoUELP1xIAcNAwKAysYmfp3AyhO0EIOJipzQ4KEAsZFIkQ45aVA8oPzIc9SRnyFxfmzjT6PELUeuu+Q1BLyJM5YnpcCANXqSN8XrZ1D1atTx0ZGa7SF4RlzBfaNQYnh4HR0vZXFbIo5mPUNCScrRs5h6xajcbTVbczkEZopWXitXFyh96rcHRXta50vecRHl7uXcXNYA6GACBHiQMBhMOsmMVjEx2KV1mEC+EuRAkYjAAiAa//twxPCAEyEZKe5li+JIIyT9zCV8QxggAE1HMm8JxNs7hh6xfzpmuP7OY3r5zH9ulzaKqx2+avxwVBIK793I++0Oxmgp3IJVk6iTOlg2SiuItaAMAgh4rQgkRw237VpII0+l6aupokTlmpMqI5INXjGEquSaTTaqRMjKZNRvXkNkNZbkAE0zmujcCEgIUdAgACRpGikAQUAjAtYxEdD9wFSAHQuXlYwIwYX5hjKYhachumQHzlhMuJQ7SbwoTgMZ00hhbujgJZhe2/5MhcmE2oHZU98CtepJXal5ASRmoktrMlRx1WbB5AXCmdtIdobR99n2+rO2SOwNx6ugfl7rsMuP2hc+JacHhzBhaarC6U+aMrP2q03v9J6+4CnAZ0AgjooAARB5jxgELiIKIczCUqOnD1AAZHDoCP/7cMTtABK9Fy3t4YviUKKlPcwlfB6AgcAgJC78xiggxQ4SRDy529WFMpdS50EyYjBKwzXYTuAAopES00cBdK+IMoNsv4pIlX6gndAwT79Y0ZXMW7z5dxXqWnjIlmvI0SSY2eMIzRKFYTJJigIHSMRSLNOOGoHD95AQZ6ubC3RMGKMGEWlI3YZI/dKWcAxQABHIACAcLmrGCxiSCAYBYg6wqbSzg8SgEC2CBgODu78IicoFTzJldq9W06UIZtMTMlkx8FQPLaCLrYMABQHC72ChE461mUJmuIw1f0dZ9DsdQQBKlqtluBVloKHyVAVHAXTC5E4oh1Jz1DWr5SMlSmWQDq8DZJjhUqXEY4SxJhKosJRwRHnjDiM2IZHjNNE4kKj8TDjwleSutmW2Mv0o4BJoIEDPYMOBcqj/+3DE6gASVRUlrmWL6lGi5LXHmqUQSERjcGCAAmC60d/IJeYxoOVxpiiETg5k/8uf101IHHEP33CPO+pMaB0kcpY8a8LI5NEvFCRetCOnzt3CYcoR1nbPltULObzEom75AcGTrpUL1YUlyWVzc/iEUsH44RnCfYcmuV+Fy2O2a9Dcfy/K2GbMrIC0miif9jnVjLbFVdUq88aP1ytPZ5avOG0sTDNKCQBiIAQIOiAABACzEjCoBgUTSOJhaShxWCpEEYKFwwAAZbIBAMIUrWd1iqIfxTaw9LJeQgq0FDUruxKRgdhFtxYm6IUeMRN/J3tiDSorK+PI1uVLme+Iv/LYuVVj6nx2MoEIprGEgZj4fVAwXqwrz59TSnO79bp5W+tu6/a7ek1YyubTrlyFZtLbblWxbPUa1xZE//uAxOiAVC0bIa5lK+JwoyR9zTF89rDhmYqmj5b7kUUCYWcgCqYgQR+JggAkADQpMOg4x6B10GDS2c3AgkAzBQOTeQTmBA6UFnnrt0BfcCFrb7Ybgw+JXL1zEjG/MYoJshIIWIQxTO9PA4ibOL0MDh13nlqRWT0pUNV4cwUGlWzoQOjweiUQDQ6CjbL4xqaewmnXYVtY8q+TKu5KqcrCONl7Y+T8YW0uhzwUbjJArGZOjl07SwCGkgMEO0iQCqVkwQZ6SGGFKHYE+p7o8r4ygCISZY5igcm4WuIV5RToBR96FUnyZ3oRHrmdrhWtCopbuJ3Fx3H/DtwhEjG6dwJTB8QgWGZE85YGPKy3FCV6wicdGNiqLG3F5IOEhYVSrj9h+/5j85qhfe/dU8oq2NNAuO5YlCeYUUZvj1tYszC3ONIBw1Rag21x4D3AAQ9IgABQBhQIjgIMMicqAIcsJj4lEgDEY2EhCJAcwUDzZKf/+3DE9YAUDRcj7uWL6kajJX3MJXx2m5dGAjYQf25S25Wy1zM8pyHQ06SQHRO+hgxBW6d7XloBHWb2WKLTzDWi6hUtdYdGHz+yiM6hdgsuAYTQPj4PziUdBJK7vU5tCZjbv731X06trQnvL8ovP/girHZdZlq6Eluyf7G8hQnp/DjULUN3o5FVTApQABHIAABixiUppuCxoNAgwkfE5+H4wcA8z5YkArWMEIAwB3VyNfaQYMGdRXb7Wrv6n0ljdmKORHQIxv5W8DYTMgiIzFYGoHfAiNa+n8LhodRYKWyfO+4bM0GmoVLFXGUw9hbwvYvKztwXgkqx3vmpuzQx2l3Xwyxu3qli3D8AxytcoqOrPw1MQw9Msl8fs01yVvXDjkvvnFoclk5POxfgaXzc3DMQhn4thGKChitu//twxO6AElkXKe3li+JioqS1zLF9xbqv+v6FAM2AAhwBEHJgeARgGAwEBUHAUYeDudzAMDgtMIQfMFQdSmEAOAqqmpL6d/xwSesGn19uWqzM4UjD+EciRxyUA34Pk5fcGi0U5RjclQINM2ssSZjKUFEJsujky+xfcoWnJS+02cNIRyH7okDJBHcIDxO6wfQ2ybvsP2XN5DZNFBYwFMZVSK1NF1TNChbuqUtHEKm5UKrA78cLDlaIpZs3VkvXhLrilAwgBCXIIKBg4AxhGAgIBEwEBRAOYUGscGBKAgUMRwVMAwFfgVAoykXUe+5TiAQqPXbVDjG2hOTAlPKqY7i4vRblhISVUC9U/hNywzzCgWLt6wxfTMGHTrzQiIjq47Blim17PorGBUJjwrPCEjHymyVSjC1jHkkh6v/7gMTqgFbRGR2s90JilKMj9d0xfKNmU1E7TQBllF8Rj8ydwyqYQWVmiwnWGCFxsWMH1wzBkdJ2EcxsoJKvd96kkAmWQCCD0soAkJI8BisxgCUXBmkdQQrkEAuYyHmNARopEaGFw9Ln3cgSAgxBk1Nv3haI32VJf8BaeyXxSJjowaFq2O/qkobPtNi81bh3HGeihYSZWLqIIyBoZJwCiYTiuElwsiFCyVKYy1jUX8tKTaJeCUXGWrZYbTUZzGOsu9FicR9lhJJpVHopdZ8amaQMtdqH9A+YBBHaQUBhkUmEAIAg2SARDiIZgZpIK+jGg9GgmJCAMG5Gm787jOJLnOO/UtpMX0bKr6rOztc0E4Vy1KFG0zWD3M8M1StXwhhVd/11u5QulG3kGTVtrQL202qjtYJ5OPYyC2OyoVLHLoTf1+km2HPrLwrXnytEiy/v5DbLOLYWFVLIblGy8hkmGJ15orHSVWT+X3oknik1//uAxOiAFJEXI67lK+JNoqV9vCYlG9Pj5CfMNrWQCUYAIGfGygAYDkIokmZOFMhMDhD5Q97gEymCgj8gEbCpnfpsKdgAFBvVm23SHnu1nfumEmEX7EEpxkTNquG7hIam+RVn9cuA9ySv5KO1qo7liFYVvE5kSiQibCJ8mh2J1kGdg58UL5rvewbNssJM3Nq2mqWSqTE+jncVIJL3AkTFSX16M/0BkkAVtAqIABPQIAAgAkKhcYCgIYKgcpEwxB4TSMmDIrBAOBROckAsiGSuGKWOIZFeBbtNDE00dUsHz07LaxoGNHANyMt3LKiQT6WniokTKwF1m7SIadlpECu6/dAIiYZ/V8xWwlmM8L8AkVIEapDeId4FLO417a11m0aFLBwvLJ69BKlQdnKAXCAgLHEIrrYTqtaMRoikfV9DOCm+hrVi9wtsuLT+JEBkgACOAAEBwIYijSDAZMAAGMNVNOixGIg+MSgoMIg0QbD/+3DE+IAUERsnrmWL4iwipb28JX2wNiRR+6KclQqVNOxcqIz9Vuqp3gfONZvUZuA/FSs6c+JDFgcK9iAxxO4+TMFJqZoDBkC5kONzXaSA0vLfPy8hNcdvUjbHVMy6QiMqYFXOjbGi1e71XcOC21rNMrIuorW3vXjajE9e54G6zqWM9hMMS8ZPPXOUqrrpWt1XjTFWY7XLPCcCu491XXOWOXQGWABhyAAAq0rBUoBwdBEkBYwJgE0tHowBAUMBQBAYycMAgaAZ8IYjkBlqDE8IoXUncG4PyxCS0VJXMEBJBowMJN5VAxaKSDxt0n2wERGKw5RKd0y6BeyUsxcd5F2jJi/7EzVk8uJSLBPfOyY0tYOGazp/de1Hzhkt6+rS+rPFpcJkfVUcM0oyKzaRs4Qjwvl1/zFM6qFT//uAxPSAFFUVIa7pi+q4ouP13T18JdKpXSEwmOJIWUNpbqHABCRwDAIMGWNGGQbMQRdMZZ5NhD8Mlg4MQAQBgTGAwNLCmAYDK8huu/pCDAHyCQBnFDK2tKoqcRCgcNDMy9YwQhAycjiHIxBdglJSXq5gUSxKJZQOGGECKrRF7kU4HSPChh79/hZpZbZz3R2E4nn5KItH4GfydlsftSnPlSt2vbvSylw1CrNuV7ilaQRiGIEdiPx6UyuUQmRT0Wmn+pqR9Ycp8LMImMH6fSg5GYtKLDz0MgsQVMiP+pUAABOhwAgqWlQJhMPAUVBYMEJmVAOFxzSsAEwNgaza6BICwQplaAKCwEpg7A1tLMIoBYwfQKAUFqYMYUZg/BCmBsBQdqB5gUEmeiiYdBIcETDoiMFiUwUIg1ctgAg2MPAsdA4BBC3wQEjGodEQiMuBcLAQGgBUQOHahgIAalBdIcCKDoMCYkZmUFBGFAUBhQb/+4DE+AFUxRkfruGUouSi47a7oAQuDwXBYBCBQEzAQDCwJBwZiK1waBVfCwNLpoXlv00C9BbhzBCAHgLtEABeYuDbeOBYm1x+WotnZWzuia0j43i0F2ryYmpk2NzHdclqAQAlE34gRuCwSli2WXq7Z00hFRuqnKtrqMSaU3zAY6xFozjwP7fPdnl//stG27KH+QAOo4kNxd+4gyUCgQRgMCgZYdSKlLqNOaU+f///3+bz//59ixd7b1hY33PusOP7EZDDU1D0RzjMevRqbppT3T/8mk4AzZB36gkBiR0ciHd3aVMQCcIKAEQzdc2NNRwUFgsZdl+WYomoOgprIDCpQJFZQaIlAkDZ7TkkmNqrVrstLl1YFy576rVq79rWvWarWcta1vsuXLpqytW/Vl2uNLl3Za1pqyt/a1rOWXVm1rfNa2taZmZma1rNmly7mly572Tk99latrkFKkxBTUUzLjEwMKqqqqqqqqqqqv/7kMT0ACtRmy257iIB6qMi/7DABaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="), document.addEventListener("WeixinJSBridgeReady", (() => t.play()), !1), this._log("info", "version: " + C.version) } async _initialize() { if (!this._initialized) { if (this._initialized = !0, this._log("info", "initializing..."), null == this._webrtcSupport && await this.detect(), !this._webrtcSupport) throw this._initialized = !1, this._log("error", "initialize complete: webrtc not support"), new Error("webrtc not support, please run detect for more information."); this._hangAudioPlayer.initialize(), zteWebrtc.regEvent("onRegister", ((e, t) => { let r = { result: e, info: t, action: this._action.name }; this._log("info", "onRegister:", r), "register" == this._action.name ? (this._action.callback(r), this._online || 0 != e || (this._online = !0, this._emit("online"))) : 0 == e ? this._online || (this._online = !0, this._emit("online")) : this._online && (this._online = !1, this._emit("offline", r)) })), zteWebrtc.regEvent("onUnRegister", ((e, t) => { let r = { result: e, info: t, action: this._action.name }; this._log("info", "onUnRegister:", r), "unregister" == this._action.name ? (this._action.callback(r), 0 == e && this._online && (this._online = !1, this._registered = !1, this._emit("offline", r))) : this._online && 1 == e ? this._registerWithFailover(this._agentId, this._sipNo, this._sipPwd).then((e => { 0 != e.result && (this._online = !1, this._registered = !1, this._emit("offline", r)) })).catch((e => { this._online = !1, this._registered = !1, this._emit("offline", r) })) : (this._online = !1, this._registered = !1, this._emit("offline", r)) })), zteWebrtc.regEvent("onRinging", ((e, t, r, i, n) => { let o = { type: e, calling: t, called: r, callid: i, extendInfo: n, action: this._action.name }; this._log("info", "onRinging:", o), this._call = { callid: i, calling: t.replace(/(sip:)?([^@]+)?(@.*)?/i, "$2"), called: r, ringTime: new Date, answerTime: null, releaseTime: null, state: "ringing" }, this._emit("ringing", { call: { ...this._call } }), this._autoAnswer && this.answer() })), zteWebrtc.regEvent("onTalking", ((e, t, r, i) => { let n = { calling: e, called: t, callid: r, extendInfo: i, action: this._action.name }; this._log("info", "onTalking:", n); let o = !1; r != this._call.callid ? (o = !0, this._log("warn", "unexpect call id: expect " + this._call.callid + " but " + r + ", some events may have been missed")) : "answered" != this._call.state && "talking" != this._call.state && (o = !0, this._log("warn", "unexpect call state: expect answered/talking but " + this._call.state + ", some events may have been missed")), this._call = { callid: r, calling: e.replace(/(sip:)?([^@]+)?(@.*)?/i, "$2"), called: t, ringTime: o ? null : this._call.ringTime, answerTime: o ? null : this._call.answerTime, releaseTime: null, state: "talking" }, this._emit("talking", { call: { ...this._call } }) })), zteWebrtc.regEvent("onRelease", ((e, t, r, i) => { let n = { calling: e, called: t, callid: r, extendInfo: i, action: this._action.name }; if (this._log("info", "onRelease:", n), !r?.length) return void ("release" == this._action.name && (n.releaser = "self", this._action.callback(n))); if (r == this._call.callid && "released" == this._call.state) return void this._action.callback(n); let o = !1; r != this._call.callid ? (o = !0, this._log("warn", "unexpect call id: expect " + this._call.callid + " but " + r + ", some events may have been missed")) : "release" == this._action.name ? "releasing" != this._call.state && (o = !0, this._log("warn", "unexpect call state: expect releasing but " + this._call.state + ", some events may have been missed")) : "talking" != this._call.state && "answering" != this._call.state && "answered" != this._call.state && "ringing" != this._call.state && (o = !0, this._log("warn", "unexpect call state: expect talking/answering/answered/ringing but " + this._call.state + ", some events may have been missed")), this._call = { callid: r, calling: e.replace(/(sip:)?([^@]+)?(@.*)?/i, "$2"), called: t, ringTime: o ? null : this._call.ringTime, answerTime: o ? null : this._call.answerTime, releaseTime: new Date, state: "released" }; let a = "peer"; "release" != this._action.name || o || (a = "self", this._action.callback(n)), this._emit("released", { call: { ...this._call }, releaser: a }), this._hangAudioPlayer?.play() })), this._log("info", "initialize complete") } } async detect() { return this._log("info", "webrtc detecting..."), await new Promise(((e, t) => { webrtcDet.detectRun((t => { const { abilityDet: r, deviceDet: i } = t, { webrtcSupport: n, websocketSupport: o, deviceSupport: a } = r; let s = i.microphoneAllowed && !!i.audioinputArr.length, c = webrtcDet.getBrowserUA().toLowerCase().indexOf("micromessenger") > -1 || "safari" == webrtcDet.getBrowserTypeVer().name.toLowerCase() || !!i.audiooutputArr.length; this._webrtcSupport = n && o && a && s && c, this._webrtcSupport && this._log("info", "webrtc detect complete, this browser supports the webrtc well."), n || this._log("warn", "webrtc: not support"), o || this._log("warn", "websocket: not support"), a || this._log("warn", "device api: not support"), i.microphoneAllowed ? i.audioinputArr.length || this._log("warn", "microphone: not found") : this._log("warn", "microphone: not allowed"), c || this._log("warn", "speaker: not found"), e({ all: this._webrtcSupport, webrtc: n, websocket: o, device: a, audio: { microphone: s, speaker: c } }) })) })) } async register(e, t, r, i) { let n = { autoAnswer: !0, heartbeatTime: 2e4, connectTimeout: 2e3, socketTimeout: 5e3, logUrl: "", ...i }; if (!n.wssUrl?.length) throw new Error("wssUrl can't be null or empty"); if (!n.sipUrl?.length) throw new Error("wssUrl can't be null or empty"); if (!e?.length) throw new Error("agentId can't be null or empty"); if (!t?.length) throw new Error("sipNo can't be null or empty"); if (this._autoAnswer = n.autoAnswer, this._wssUrl = n.wssUrl, this._sipUrl = n.sipUrl, this._logUrl = n.logUrl, this._heartbeatTime = n.heartbeatTime, this._connectTimeout = n.connectTimeout, this._socketTimeout = n.socketTimeout, this._resolveSGW(), this._logUrl?.length && (this._logger = new WebLogger), this._logger?.disconnect(), this._logger?.connect(`${this._logUrl}?agentId=${e}`), this._log("info", "version: " + C.version), this._log("info", "registering:", { agentId: e, sipNo: t, sipPwd: r, ...i }), this._registered) { let e = { result: 99, info: "this client is already registered" }; return this._log("error", "register failed:", e), Promise.resolve(e) } return await this._registerWithFailover(e, t, r) } async _register(e, t, r, i) { return this._log("info", "- registering to " + i + ":", { agentId: e, sipNo: t, sipPwd: r }), await this._invoke("register", (() => { zteWebrtc.register(t, i, this._heartbeatTime, r, this._sipUrl, this._connectTimeout, "") })).then((e => (0 == e.result ? this._log("info", "- register to " + i + " complete:", e) : this._log("error", "- register to " + i + " failed:", e), e))).catch((e => { throw this._log("error", "- register to " + i + " failed: " + e.message), e })) } async _registerWithFailover(e, t, r) { this._sipNo = t, this._agentId = e, this._sipPwd = r; let i = null, n = [this._sgw, this._nextSGW()]; for (let o of n) if (o) { this._sgw = o; try { const i = await this._register(e, t, r, o); if (0 == i.result) this._registered = !0, this._log("info", "register complete:", i); else { if (1 == i.result) throw new Error(i.info); this._log("error", "register failed:", i) } return i } catch (e) { i = e } } if (i) throw this._log("error", "register failed: " + i.message), i } async unregister() { if (this._log("info", "unregistering..."), !this._registered) { let e = { result: 99, info: "make sure this client is registered" }; throw this._log("error", "unregister failed:", e), new Error(e.info) } return await this._invoke("unregister", (() => { zteWebrtc.unRegister() })).then((e => (0 == e.result ? (this._sipNo = "", this._agentId = "", this._registered = !1, this._log("info", "unregister complete:", e)) : this._log("error", "unregister failed:", e), Promise.resolve(e)))).catch((e => (this._log("error", "unregister failed: " + e.message), Promise.reject(e)))) } async answer() { let e = null; switch (this._call.state) { case "answering": case "answered": case "talking": e = new Error("call already been answered"); break; case "releasing": case "released": e = new Error("call already been released") }if (e) throw this._emit("answered", { call: { ...this._call }, error: e }), e; let t = this._call.state; if (this._call.state = "answering", this._log("info", "answering..."), this._emit("answering", { call: { ...this._call } }), !this._call.callid?.length) throw new Error("no call to be answered"); return await zteWebrtc.answer(1, !1, this._mediaParam, this._mediaTag, this._slidesParam).then((e => { if (1 == e) return this._call.state = "answered", this._log("info", "answer complete:", { result: e }), this._emit("answered", { call: { ...this._call }, error: null }), Promise.resolve(e); throw new Error("server error") })).catch((e => (this._call.state = t, this._log("error", "answer failed: " + e.message), this._emit("answered", { call: { ...this._call }, error: e }), Promise.reject(e)))) } async release() { if (!this._call.callid?.length) throw new Error("no call to be released"); if ("answering" == this._call.state) throw new Error("previous operation was not completed"); if ("ringing" != this._call.state && "answered" != this._call.state && "talking" != this._call.state) throw new Error("call already been released"); let e = this._call.state; return this._call.state = "releasing", this._log("info", "releasing..."), await this._invoke("release", (() => { zteWebrtc.releaseCall() })).then((e => (this._call.state = "released", this._log("info", "release complete:", e), Promise.resolve(e)))).catch((t => (this._call.state = e, this._log("error", "unregister failed:" + t.message), Promise.reject(t)))) } on(e, t) { if (!this._eventHandlers[e]) throw new Error("operation not support"); return this._eventHandlers[e].add(t), this } off(e, t) { if (!this._eventHandlers[e]) throw new Error("operation not support"); let r = this._eventHandlers[e]; return t ? r.delete(t) : r.clear(), this } _emit(e, t) { if (!this._eventHandlers[e]) throw new Error("operation not support"); this._log("info", "fire event: name=" + e + ", args=", t), this._eventHandlers[e].forEach((e => setTimeout((() => e(t)), 0))) } _log(e, t, r) { let i = "[webrtc-cli] " + t.trim(); ":" !== i.slice(-1) && "=" !== i.slice(-1) || (i += " ", i += r ? JSON.stringify(r) : "(null)"), console[e].apply(this, [i]) } async _invoke(e, t) { if (await this._initialize(), this._action.name) throw new Error("previous operation was not completed"); this._action.name = e; let r = new Promise(((e, t) => { setTimeout((() => { t(new Error("operation timeout")) }), this._socketTimeout) })), i = new Promise(((e, r) => { this._action.callback = t => { e(t) }; try { t() } catch (e) { r(new Error("something error")) } })); return await Promise.race([i, r]).finally((e => this._action = {})) } _resolveSGW() { const e = this._wssUrl.indexOf(":"), t = this._wssUrl.substring(0, e); let r = this._wssUrl.substring(e + 3).split("|").map((e => t + "://" + e)); this._masterSGW = r[0], this._slaveSGW = r.length > 1 ? r[1] : null, this._sgw = this._masterSGW } _nextSGW() { return this._sgw == this._masterSGW ? this._slaveSGW : this._masterSGW } } Object.assign(window, { md5: t(), MobileDetect: n(), zteUtils: a(), webrtcPFM: c(), webrtcConfig: d(), webrtcWS: p(), webrtcPC: f(), webrtcSDP: m(), webrtcDet: b(), zteWebrtc: v(), WebAudioPlayer: class { constructor(e) { this._audioDataString = e, this._audioBuffer = null, this._initialized = !1 } initialize() { if (this._initialized) return; this._initialized = !0; let e = this._base64ToArrayBuffer(this._audioDataString); this._audioContext = new AudioContext, this._audioContext.decodeAudioData(e, (e => this._audioBuffer = e)) } play() { let e = this._audioContext.createBufferSource(); e.connect(this._audioContext.destination), e.buffer = this._audioBuffer, e.start(0) } _base64ToArrayBuffer(e) { let t = (e + "=".repeat((4 - e.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"), r = atob(t), i = new Uint8Array(r.length); for (let e = 0; e < r.length; ++e)i[e] = r.charCodeAt(e); return i.buffer } }, WebLogger: class { get url() { return this._url } get connected() { return this._socket?.readyState == WebSocket.OPEN } get storage() { return this._storage._engine } constructor() { this._url = null, this._socket = null, this._tid = 0, this._storage = [], this._overrideConsoleMethods() } async connect(e) { return this._url = e, this._start(), new Promise(((e, t) => { this._doConnect(e) })) } disconnect() { this._stop(), this._socket?.close() } _overrideConsoleMethods() { let e = ["log", "debug", "info", "warn", "error"]; for (let t of e) { let e = console[t]; this["_console_" + t] = e, console[t] = r => { let i = `${this._now()} [${t.toUpperCase().padStart(5, " ")}]`; "object" == typeof r && null != r.length ? r.unshift(i) : r = [i, r]; let n = r.join(" "); e(n), this._save(n) } } } _save(e) { this._storage.push(e) } async _upload(e) { if (!this.connected) return Promise.reject(new Error("WebSocket is not connected")); let t = new Promise(((t, r) => { this._responsePromise = { resolve: t, reject: r, crc: "" + e.length }, this._socket.send(e) })), r = ++this._tid, i = new Promise(((e, t) => { setTimeout((() => { r == this._tid && (this._responsePromise = null, t(new Error("Network timeout"))) }), 5e3) })); return Promise.race([t, i]) } async _start() { for (this._running = !0; this._running;) { if (!this.connected) { await this._sleep(3e3); continue } let e = this._storage.shift(); if (e) try { await this._upload(e) } catch (t) { this._console_error(this._now() + " [webrtc-logger] upload failed: " + t.message), this._storage.unshift(e) } else await this._sleep(1e3) } } _stop() { this._running = !1 } async _sleep(e) { return new Promise(((t, r) => { setTimeout(t, e) })) } _doConnect(e) { if (this._running) { console.info("[webrtc-logger] connect to " + this._url); try { this._socket = new WebSocket(this._url), this._socket.onopen = t => { console.info("[webrtc-logger] connect success"), e() }, this._socket.onclose = t => { let r = t.reason; r && r.length || (r = 1e3 == t.code ? "server closed" : "connection refused"), console.warn("[webrtc-logger] connection closed: " + r), setTimeout((() => this._doConnect(e)), 5e3) }, this._socket.onmessage = e => { let t = this._responsePromise; t && t.crc == e.data && (this._responsePromise = null, t.resolve()) } } catch (t) { console.error("[webrtc-logger] connect failed: " + t.message), setTimeout((() => this._doConnect(e)), 5e3) } } } _now() { let e = new Date; return e.getFullYear() + "-" + (e.getMonth() + 1).toString().padStart(2, "0") + "-" + e.getDate().toString().padStart(2, "0") + " " + e.getHours().toString().padStart(2, "0") + ":" + e.getMinutes().toString().padStart(2, "0") + ":" + e.getSeconds().toString().padStart(2, "0") } }, WebrtcClient: C }) })() })();